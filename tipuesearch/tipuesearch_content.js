var tipuesearch = {"pages":[{"title":" ecasglez's FortranUtilities ","text":"ecasglez's FortranUtilities Note This is Work-in-Progress. More functions are being added. ecasglez's FortranUtilities is a collection of simple functions for Fortran programs. Functions for strings, numbers, precision, statistics and files are included. See the specifications of the different functions. More functions for different tasks will be included in the future. This is a BETA version. All functions work properly on Linux using gfortran 7.5 or newer, and all functions except symlink functions work on Windows using gfortran 7.5 (MSYS2-Mingw-w64) or newer. More compilers will be tested in the future. Downloading The latest version of this library can be obtained from the GitHub repository located here . Compilation Check that you have cmake version 3.10 or newer, a Fortran compiler compatible with Fortran 2008, and a C++ compiler compatible with C++17. Download the files and enter directory FortranUtilities. Then create a build directory and enter that directory: mkdir build cd build Type: cmake .. Optionally you can select an install directory by typing: cmake .. -DCMAKE_INSTALL_PREFIX=/installation/path/ On Windows using MSYS2-Mingw-w64 use: cmake .. -G \"MinGW Makefiles\" Compile: make On Windows using MSYS2-Mingw-w64 use instead of make: mingw32-make.exe Install: make install A static and and a shared library are created. Test programs for both libraries are created too. Documentation Documentation of the different functions is here . Usage To use the library in your programs you first need to use the module of interest, as in the following example: PROGRAM test USE FU_Strings WRITE ( * , * ) int2str ( 5 ) END PROGRAM test Then you have to link to the library when compiling. For example: To use the static library: gfortran program.f90 -o program -lFortranUtilitiesStatic -L/path/to/the/library/folder -I/path/to/include/folder -lstdc++ To use the shared library: gfortran program.f90 -lFortranUtilities -L/path/to/the/library/folder -I/path/to/include/folder Contact Developed by Emilio Castro. Create a Issue in GitHub if you have any suggestion, comment, enhancement, bug, etc. License These files are distributed under a MIT license. See LICENSE file for more information on using and distributing these files. Developer Info Emilio Castro","tags":"home","loc":"index.html"},{"title":"Prec_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Prec Source Code Prec_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Prec !! author: Emilio Castro. !! date: 13/05/2020 !! version: 1.0. !! license: MIT. !! summary: Precision parameters to use in Fortran programs. !! Precision parameters to use in Fortran programs with real or integer variable types. USE ISO_FORTRAN_ENV IMPLICIT NONE INTEGER , PARAMETER :: sp = REAL32 !! Kind parameter to specify a real type with a storage size of 32 bits. INTEGER , PARAMETER :: dp = REAL64 !! Kind parameter to specify a real type with a storage size of 64 bits. INTEGER , PARAMETER :: qp = REAL128 !! Kind parameter to specify a real type with a storage size of 128 bits. INTEGER , PARAMETER :: i8 = INT8 !! Kind parameter to specify an integer type with a storage size of 8 bits. INTEGER , PARAMETER :: i16 = INT16 !! Kind parameter to specify an integer type with a storage size of 16 bits. INTEGER , PARAMETER :: i32 = INT32 !! Kind parameter to specify an integer type with a storage size of 32 bits. INTEGER , PARAMETER :: i64 = INT64 !! Kind parameter to specify an integer type with a storage size of 64 bits. END MODULE FU_Prec","tags":"","loc":"sourcefile/prec_m.f90.html"},{"title":"Timing_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Timing Source Code Timing_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Timing !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Tools to measure time spent by functions in Fortran programs. !! Tools to measure time spent by functions in Fortran programs. !! The user can use IntervalTime to get the time since the last measure or the time !! since the begining of the execution if no previous measuement is available. This point !! will be used as a starting point for the next interval. !! Use TotalTime to get the time since the beginning of the program or since the last time !! resetTotalTime is executed. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: ResetTotalTime , TotalTime , IntervalTime INTERFACE SUBROUTINE c_ResetTotalTime () BIND ( c , name = 'c_ResetTotalTime' ) USE iso_c_binding END SUBROUTINE c_ResetTotalTime FUNCTION c_TotalTime_sp () RESULT ( res ) BIND ( c , name = 'c_TotalTime_sp' ) USE iso_c_binding REAL ( KIND = C_FLOAT ) :: res END FUNCTION c_TotalTime_sp FUNCTION c_TotalTime_dp () RESULT ( res ) BIND ( c , name = 'c_TotalTime_dp' ) USE iso_c_binding REAL ( KIND = C_DOUBLE ) :: res END FUNCTION c_TotalTime_dp FUNCTION c_IntervalTime_sp () RESULT ( res ) BIND ( c , name = 'c_IntervalTime_sp' ) USE iso_c_binding REAL ( KIND = C_FLOAT ) :: res END FUNCTION c_IntervalTime_sp FUNCTION c_IntervalTime_dp () RESULT ( res ) BIND ( c , name = 'c_IntervalTime_dp' ) USE iso_c_binding REAL ( KIND = C_DOUBLE ) :: res END FUNCTION c_IntervalTime_dp END INTERFACE INTERFACE TotalTime !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Gets the time in seconds since the beginning of the program or since the last time resetTotalTime is executed. !! TotalTime gets the time in seconds (with a precision of microseconds) !! since the beginning of the program or since the last time resetTotalTime is executed. !! !! You can use mold input argument to indicate the precision of the output number. Default precision !! is the default precision of your compiler. MODULE PROCEDURE TotalTime_def MODULE PROCEDURE TotalTime_sp MODULE PROCEDURE TotalTime_dp END INTERFACE TotalTime INTERFACE IntervalTime !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Gets the time in seconds since the last measurement. !! IntervalTime gets the time in seconds (with a precision of microseconds) !! since the last measurement or the time since the begining of the execution if no previous !! measuement is available. This point will be used as a starting point for the next interval. !! !! You can use mold input argument to indicate the precision of the output number. Default precision !! is the default precision of your compiler. MODULE PROCEDURE IntervalTime_def MODULE PROCEDURE IntervalTime_sp MODULE PROCEDURE IntervalTime_dp END INTERFACE IntervalTime CONTAINS SUBROUTINE ResetTotalTime () !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Sets the starting point to count the total time. !! Sets the starting point to count the total time. IMPLICIT NONE CALL c_ResetTotalTime () END SUBROUTINE ResetTotalTime FUNCTION TotalTime_def () RESULT ( res ) IMPLICIT NONE REAL :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses default precision of the compiler used. res = REAL ( c_TotalTime_dp ()) / 1.E6 END FUNCTION TotalTime_def FUNCTION TotalTime_sp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_TotalTime_sp () / 1.E6_sp END FUNCTION TotalTime_sp FUNCTION TotalTime_dp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_TotalTime_dp () / 1.E6_dp END FUNCTION TotalTime_dp FUNCTION IntervalTime_def () RESULT ( res ) IMPLICIT NONE REAL :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses default precision of the compiler used. res = REAL ( c_IntervalTime_dp ()) / 1.E6 END FUNCTION IntervalTime_def FUNCTION IntervalTime_sp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_IntervalTime_sp () / 1.E6_sp END FUNCTION IntervalTime_sp FUNCTION IntervalTime_dp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_IntervalTime_dp () / 1.E6_dp END FUNCTION IntervalTime_dp END MODULE FU_Timing","tags":"","loc":"sourcefile/timing_m.f90.html"},{"title":"Strings_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Strings Source Code Strings_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Strings !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Useful tools to manipulate strings in Fortran programs. !! Useful tools to manipulate strings in Fortran programs. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: num2str , int2str00000 , str2num PUBLIC :: startsWith , endsWith , splitstr , replace , mergeChars PUBLIC :: upper , lower , cistrcmp CHARACTER ( LEN =* ), PARAMETER :: lowercase = 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' CHARACTER ( LEN =* ), PARAMETER :: uppercase = 'AÁÄÀÂBCDEÉËÈÊFGHIÍÏÌÎJKLMNÑOÓÖÒÔPQRSTUÚÜÙÛVWXYZ' INTERFACE splitstr !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Splits a string. !! Splits a string and returns the portion selected by the user. MODULE PROCEDURE splitstr_i8 MODULE PROCEDURE splitstr_i16 MODULE PROCEDURE splitstr_i32 MODULE PROCEDURE splitstr_i64 END INTERFACE splitstr INTERFACE num2str !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts number into a string. !! Converts an integer or real variable into a string variable. !! Useful to open files named sequentially. MODULE PROCEDURE num2str_i8 MODULE PROCEDURE num2str_i16 MODULE PROCEDURE num2str_i32 MODULE PROCEDURE num2str_i64 MODULE PROCEDURE num2str_sp MODULE PROCEDURE num2str_dp MODULE PROCEDURE num2str_qp END INTERFACE num2str INTERFACE int2str00000 !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts an integer into a string filling with leading zeros. !! Converts an integer variable into a string variable, !! filling with leading zeros up to the limit imposed by the user. !! Useful to open files named sequentially with leading zeros in the name. MODULE PROCEDURE int2str00000_i8 MODULE PROCEDURE int2str00000_i16 MODULE PROCEDURE int2str00000_i32 MODULE PROCEDURE int2str00000_i64 END INTERFACE int2str00000 INTERFACE str2num !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string into an integer or real. !! Converts a string into an integer or real number as specified by the type of variable mold. MODULE PROCEDURE str2num_i8 MODULE PROCEDURE str2num_i16 MODULE PROCEDURE str2num_i32 MODULE PROCEDURE str2num_i64 MODULE PROCEDURE str2num_sp MODULE PROCEDURE str2num_dp MODULE PROCEDURE str2num_qp END INTERFACE str2num CONTAINS PURE FUNCTION splitstr_i8 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i8 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :), ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i8 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i8 PURE FUNCTION splitstr_i16 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i16 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i16 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i16 PURE FUNCTION splitstr_i32 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i32 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i32 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i32 PURE FUNCTION splitstr_i64 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i64 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i64 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i64 PURE FUNCTION mergeChars ( str , c ) RESULT ( res ) !! author: Emilio Castro. !! date: 14/08/2020. !! version: 1.0. !! license: MIT. !! summary: Merge characters in a string if they are contiguous. !! Merge characters in a string if they are contiguous. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to search inside for contiguous duplicated characters. CHARACTER ( LEN =* ), INTENT ( IN ) :: c !! Character to search for contiguous duplications. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String with the selected character contiguous duplications removed. CHARACTER ( LEN = :), ALLOCATABLE :: string INTEGER :: pos string = str res = '' pos = INDEX ( string , c ) DO WHILE ( pos /= 0 ) res = res // string (: pos ) string = string ( pos + 1 :) pos = INDEX ( string , c ) DO WHILE ( pos == 1 ) string = string ( 2 :) pos = INDEX ( string , c ) END DO END DO res = res // string END FUNCTION mergeChars ELEMENTAL FUNCTION startsWith ( str , substr ) RESULT ( res ) !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a string starts with a given substring. !! Checks if a string starts with a given substring. It can be an array of string. CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to check how it starts. It can be an array. CHARACTER ( LEN =* ), INTENT ( IN ) :: substr !! Substring to search to check if str starts with it. LOGICAL :: res !! True if the string starts with the substring and False otherwise. If !! substr is empty it returns True. If the input is an array, the returned !! values will also be in an array. res = INDEX ( str , substr ) == 1 END FUNCTION startsWith ELEMENTAL FUNCTION endsWith ( str , substr ) RESULT ( res ) !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a string ends with a given substring. !! Checks if a string ends with a given substring. It can be an array of string. CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to check how it ends. It can be an array. CHARACTER ( LEN =* ), INTENT ( IN ) :: substr !! Substring to search to check if str ends with it. LOGICAL :: res !! True if the string ends with the substring and False otherwise. If !! substr is empty it returns True. If the input is an array, the returned !! values will also be in an array. res = INDEX ( str , substr , BACK = . TRUE .) == LEN ( str ) - LEN ( substr ) + 1 END FUNCTION endsWith PURE FUNCTION num2str_i8 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i8 PURE FUNCTION num2str_i16 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i16 PURE FUNCTION num2str_i32 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i32 PURE FUNCTION num2str_i64 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i64 PURE FUNCTION num2str_sp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = sp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_sp PURE FUNCTION num2str_dp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = dp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_dp PURE FUNCTION num2str_qp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = qp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_qp PURE FUNCTION int2str00000_i8 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i8 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i8 PURE FUNCTION int2str00000_i16 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i16 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i16 PURE FUNCTION int2str00000_i32 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i32 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i32 PURE FUNCTION int2str00000_i64 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i64 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i64 PURE FUNCTION str2num_i8 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i8 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i8 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i8 PURE FUNCTION str2num_i16 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i16 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i16 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i16 PURE FUNCTION str2num_i32 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i32 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i32 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i32 PURE FUNCTION str2num_i64 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i64 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i64 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i64 PURE FUNCTION str2num_sp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = sp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_sp PURE FUNCTION str2num_dp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = dp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_dp PURE FUNCTION str2num_qp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = qp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = qp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_qp PURE FUNCTION replace ( str , search , repla ) RESULT ( res ) !! author: Emilio Castro. !! date: 10/07/2020. !! version: 1.0. !! license: MIT. !! summary: Searches and replaces a substring in a string !! Searches and replaces a substring in a string. It replaces !! all occurences. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to modify CHARACTER ( LEN =* ), INTENT ( IN ) :: search !! String to search in str. CHARACTER ( LEN =* ), INTENT ( IN ) :: repla !! String to replace in str. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Modified string. INTEGER :: pos INTEGER :: lensearch CHARACTER ( LEN = :), ALLOCATABLE :: straux res = '' straux = str lensearch = LEN ( search ) pos = INDEX ( straux , search ) DO WHILE ( pos /= 0 ) res = res // straux (: pos - 1 ) // repla straux = straux ( pos + lensearch :) pos = INDEX ( straux , search ) END DO res = res // straux END FUNCTION replace PURE FUNCTION strReverse ( str ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str CHARACTER ( LEN = :), ALLOCATABLE :: res INTEGER :: i res = str FORALL ( i = 1 : len ( res )) res ( i : i ) = res ( len ( res ) - i + 1 : len ( res ) - i + 1 ) END FUNCTION strReverse PURE FUNCTION upper ( str ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string to uppercase characters. !! Converts a string to uppercase characters. It works with this dataset: !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to uppercase characters. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String converted to uppercase characters. INTEGER :: i , pos res = str DO i = 1 , LEN ( res ) pos = INDEX ( lowercase , res ( i : i )) IF ( pos /= 0 ) THEN res ( i : i ) = uppercase ( pos : pos ) END IF END DO END FUNCTION upper PURE FUNCTION lower ( str ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string to lowercase characters. !! Converts a string to lowercase characters. It works with this dataset !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to lowercase characters. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String converted to lowercase characters. INTEGER :: i , pos res = str DO i = 1 , LEN ( res ) pos = INDEX ( uppercase , res ( i : i )) IF ( pos /= 0 ) THEN res ( i : i ) = lowercase ( pos : pos ) END IF END DO END FUNCTION lower PURE FUNCTION cistrcmp ( str1 , str2 ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Case-independent string comparison. !! Case-independent string comparison. It works with this dataset: !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str1 !! First string to compare. CHARACTER ( LEN =* ), INTENT ( IN ) :: str2 !! Second string to compare LOGICAL :: res !! True if both strings are equal independently of the case. False otherwise. res = upper ( str1 ) == upper ( str2 ) END FUNCTION cistrcmp END MODULE FU_Strings","tags":"","loc":"sourcefile/strings_m.f90.html"},{"title":"Statistics_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Statistics Source Code Statistics_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Statistics !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Statistics tools for Fortran programs. !! Statistics tools for Fortran programs. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: mean , gmean , variance , stdev , pvariance , pstdev , & covariance , pcovariance , correlation , lin_error_propagation , median , & skewness , pskewness , linreg , logreg , expreg , potreg INTERFACE c_sort !To sort the array of values using c++ functions in order !to calculate median and quantiles. SUBROUTINE c_sort_float ( x , n ) BIND ( c , name = 'c_sort_float' ) USE iso_c_binding INTEGER ( C_INT ) , VALUE :: n REAL ( C_FLOAT ), DIMENSION ( n ), INTENT ( INOUT ) :: x END SUBROUTINE c_sort_float SUBROUTINE c_sort_double ( x , n ) BIND ( c , name = 'c_sort_double' ) USE iso_c_binding INTEGER ( C_INT ) , VALUE :: n REAL ( C_DOUBLE ), DIMENSION ( n ), INTENT ( INOUT ) :: x END SUBROUTINE c_sort_double SUBROUTINE c_sort_long_double ( x , n ) BIND ( c , name = 'c_sort_long_double' ) USE iso_c_binding INTEGER ( C_INT ) , VALUE :: n REAL ( C_LONG_DOUBLE ), DIMENSION ( n ), INTENT ( INOUT ) :: x END SUBROUTINE c_sort_long_double END INTERFACE c_sort INTERFACE mean !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the mean value. !! Calculates the mean value of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\overline{x} = \\frac{\\sum\\limits_{i=1}&#94;n x_{i}}{n} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = mean(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the mean value of ```x```. MODULE PROCEDURE mean_sp MODULE PROCEDURE mean_dp MODULE PROCEDURE mean_qp END INTERFACE mean INTERFACE gmean !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the geometric mean. !! Calculates the geometric mean of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\overline{x} = \\left(\\prod\\limits_{i=1}&#94;{n}x_{i}\\right)&#94;\\frac{1}{n} !! = \\sqrt[n]{x_{1} \\times x_{2} \\times \\dots \\times x_{n}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = gmean(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the geometric mean of ```x```. MODULE PROCEDURE gmean_sp MODULE PROCEDURE gmean_dp MODULE PROCEDURE gmean_qp END INTERFACE gmean INTERFACE variance !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample variance. !! Calculates the sample variance of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma&#94;{2} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n-1} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = variance(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample variance of ```x```. MODULE PROCEDURE variance_sp MODULE PROCEDURE variance_dp MODULE PROCEDURE variance_qp END INTERFACE variance INTERFACE stdev !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample standard deviation. !! Calculates the sample standard deviation of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n-1}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = stdev(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample standard deviation of ```x```. MODULE PROCEDURE stdev_sp MODULE PROCEDURE stdev_dp MODULE PROCEDURE stdev_qp END INTERFACE stdev INTERFACE pvariance !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population variance. !! Calculates the population variance of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma&#94;{2} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pvariance(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population variance of ```x```. MODULE PROCEDURE pvariance_sp MODULE PROCEDURE pvariance_dp MODULE PROCEDURE pvariance_qp END INTERFACE pvariance INTERFACE pstdev !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population standard deviation. !! Calculates the population standard deviation of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pstdev(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population standard deviation of ```x```. MODULE PROCEDURE pstdev_sp MODULE PROCEDURE pstdev_dp MODULE PROCEDURE pstdev_qp END INTERFACE pstdev INTERFACE covariance !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample covariance between two variables. !! Calculates the sample covariance between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\sigma_{xy} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)\\left(y_{i} - !!              \\overline{y}\\right)}{n-1} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = covariance(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the sample covariance of ```x``` and ```y```. MODULE PROCEDURE covariance_sp MODULE PROCEDURE covariance_dp MODULE PROCEDURE covariance_qp END INTERFACE covariance INTERFACE pcovariance !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population covariance between two variables. !! Calculates the population covariance between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\sigma_{xy} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)\\left(y_{i} - !!              \\overline{y}\\right)}{n} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = pcovariance(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the population covariance of ```x``` and ```y```. MODULE PROCEDURE pcovariance_sp MODULE PROCEDURE pcovariance_dp MODULE PROCEDURE pcovariance_qp END INTERFACE pcovariance INTERFACE correlation !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the correlation coefficient between two variables. !! Calculates the correlation coefficient between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\rho_{xy} = \\frac{\\sigma_{xy} !!                 }{\\sigma_{x} \\sigma_{y}} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = correlation(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the correlation coefficient of ```x``` and ```y```. MODULE PROCEDURE correlation_sp MODULE PROCEDURE correlation_dp MODULE PROCEDURE correlation_qp END INTERFACE correlation INTERFACE lin_error_propagation !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Performs linear error (or uncertainties) propagation. !! Performs linear error (or uncertainties) propagation given the !! sensitivity coefficients and a covariance matrix. The following !! formula is applied: !! !! \\sigma&#94;2_{y} = S \\Sigma&#94;{X} S&#94;\\intercal !! where: !! !! * y is the response whose uncertainty is to be calculated. !! * X is a set of input parameters to propagate their uncertainty to y. !! * S is the vector of sensitivity coefficients of y with respect to the !!   different parameters in X. !! * \\Sigma&#94;{x} is the covariance matrix of the parameters in X. !! !! Usage: !! !! ``` !! y = lin_error_propagation(s,m) !! ``` !! !! where: !! !! * ```s``` = vector of rank 1 with real numbers containing the sensitivity coefficients. !! * ```m``` = array of rank 2 containing the covariance matrix. !! * ```y``` = real number of the same kind as ```s``` and ```m``` with the !! error or uncertainty propagated to this new variable. MODULE PROCEDURE lin_error_propagation_sp MODULE PROCEDURE lin_error_propagation_dp MODULE PROCEDURE lin_error_propagation_qp END INTERFACE lin_error_propagation INTERFACE median !! author: Emilio Castro. !! date: 12/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the median value. !! Calculates the median value. !! This function does not work with quadruple precision numbers !! because of the ordering subroutine written in C++. !! !! Usage: !! !! ``` !! y = median(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the median of ```x```. MODULE PROCEDURE median_sp MODULE PROCEDURE median_dp END INTERFACE median INTERFACE skewness !! author: Emilio Castro. !! date: 19/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample skewness of a set of values. !! Calculates the sample skewness of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! S_{x} = \\frac{n}{\\left( n-1 \\right)\\left( n-2 \\right) !!               }\\sum\\limits_{i=1}&#94;{n}\\left( \\frac{x_{i}-\\overline{x} !!               }{\\sigma_{x}} \\right)&#94;3 !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = skewness(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample skewness of ```x```. MODULE PROCEDURE skewness_sp MODULE PROCEDURE skewness_dp MODULE PROCEDURE skewness_qp END INTERFACE skewness INTERFACE pskewness !! author: Emilio Castro. !! date: 19/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population skewness of a set of values. !! Calculates the population skewness of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! S_{x} = \\frac{1}{n !!               }\\sum\\limits_{i=1}&#94;{n}\\left( \\frac{x_{i}-\\overline{x} !!               }{\\sigma_{x}} \\right)&#94;3 !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pskewness(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population skewness of ```x```. MODULE PROCEDURE pskewness_sp MODULE PROCEDURE pskewness_dp MODULE PROCEDURE pskewness_qp END INTERFACE pskewness INTERFACE regression !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs different types of regression between two sets of values. !! Performs different types of regression between two sets of values. This is a !! private subroutine accesible by using one of [[linreg]], [[logreg]], [[expreg]] or [[potreg]]. MODULE PROCEDURE regression_sp MODULE PROCEDURE regression_dp MODULE PROCEDURE regression_qp END INTERFACE regression INTEGER , PARAMETER :: linreg_id = 1 !! Selector flag for linear regression in function [[regression]]. INTEGER , PARAMETER :: logreg_id = 2 !! Selector flag for logarithmic regression in function [[regression]]. INTEGER , PARAMETER :: expreg_id = 3 !! Selector flag for exponential regression in function [[regression]]. INTEGER , PARAMETER :: potreg_id = 4 !! Selector flag for potential regression in function [[regression]]. INTERFACE linreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs linear regression between two sets of values. !! Performs linear regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = a \\cdot x+b !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to measure the goodness of fit. !! !! Usage: !! !! ``` !! CALL linreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE linreg_sp MODULE PROCEDURE linreg_dp MODULE PROCEDURE linreg_qp END INTERFACE linreg INTERFACE logreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs logarithmic regression between two sets of values. !! Performs logarithmic regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = a \\cdot ln(x)+b !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL logreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE logreg_sp MODULE PROCEDURE logreg_dp MODULE PROCEDURE logreg_qp END INTERFACE logreg INTERFACE expreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs exponential regression between two sets of values. !! Performs exponential regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = b \\cdot e&#94;{(a \\cdot x)} !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL expreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE expreg_sp MODULE PROCEDURE expreg_dp MODULE PROCEDURE expreg_qp END INTERFACE expreg INTERFACE potreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs potential regression between two sets of values. !! Performs potential regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = b \\cdot x&#94;a !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL potreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE potreg_sp MODULE PROCEDURE potreg_dp MODULE PROCEDURE potreg_qp END INTERFACE potreg CONTAINS PURE FUNCTION mean_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_sp PURE FUNCTION mean_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_dp PURE FUNCTION mean_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_qp PURE FUNCTION gmean_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_sp PURE FUNCTION gmean_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_dp PURE FUNCTION gmean_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_qp PURE FUNCTION variance_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = sp REAL ( KIND = sp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_sp PURE FUNCTION variance_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = dp REAL ( KIND = dp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_dp PURE FUNCTION variance_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = qp REAL ( KIND = qp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_qp PURE FUNCTION stdev_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_sp PURE FUNCTION stdev_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_dp PURE FUNCTION stdev_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_qp PURE FUNCTION pvariance_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = sp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_sp PURE FUNCTION pvariance_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = dp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_dp PURE FUNCTION pvariance_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = qp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_qp PURE FUNCTION pstdev_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_sp PURE FUNCTION pstdev_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_dp PURE FUNCTION pstdev_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_qp PURE FUNCTION covariance_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = sp REAL ( KIND = sp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_sp PURE FUNCTION covariance_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = dp REAL ( KIND = dp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_dp PURE FUNCTION covariance_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = qp REAL ( KIND = qp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_qp PURE FUNCTION pcovariance_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = sp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_sp PURE FUNCTION pcovariance_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = dp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_dp PURE FUNCTION pcovariance_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = qp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_qp PURE FUNCTION correlation_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_sp PURE FUNCTION correlation_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_dp PURE FUNCTION correlation_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_qp PURE FUNCTION lin_error_propagation_sp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = sp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_sp PURE FUNCTION lin_error_propagation_dp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = dp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_dp PURE FUNCTION lin_error_propagation_qp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = qp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_qp FUNCTION median_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the median. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the median REAL ( KIND = sp ), DIMENSION ( SIZE ( x )) :: x_cp ! x_cp is a copy of x to avoid modifying it when ordering INTEGER :: size_x INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_median.f90' END FUNCTION median_sp FUNCTION median_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the median. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the median REAL ( KIND = dp ), DIMENSION ( SIZE ( x )) :: x_cp ! x_cp is a copy of x to avoid modifying it when ordering INTEGER :: size_x INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_median.f90' END FUNCTION median_dp PURE FUNCTION skewness_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = sp ) :: avg ! mean value REAL ( KIND = sp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_sp PURE FUNCTION skewness_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = dp ) :: avg ! mean value REAL ( KIND = dp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_dp PURE FUNCTION skewness_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = qp ) :: avg ! mean value REAL ( KIND = qp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_qp PURE FUNCTION pskewness_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = sp ) :: avg ! mean value REAL ( KIND = sp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_sp PURE FUNCTION pskewness_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = dp ) :: avg ! mean value REAL ( KIND = dp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_dp PURE FUNCTION pskewness_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = qp ) :: avg ! mean value REAL ( KIND = qp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_qp PURE SUBROUTINE linreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_sp PURE SUBROUTINE linreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_dp PURE SUBROUTINE linreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_qp PURE SUBROUTINE logreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_sp PURE SUBROUTINE logreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_dp PURE SUBROUTINE logreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_qp PURE SUBROUTINE expreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_sp PURE SUBROUTINE expreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_dp PURE SUBROUTINE expreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_qp PURE SUBROUTINE potreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_sp PURE SUBROUTINE potreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_dp PURE SUBROUTINE potreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_qp PURE SUBROUTINE regression_sp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = sp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = sp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = sp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_sp PURE SUBROUTINE regression_dp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = dp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = dp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = dp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_dp PURE SUBROUTINE regression_qp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = qp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = qp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = qp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_qp END MODULE FU_Statistics","tags":"","loc":"sourcefile/statistics_m.f90.html"},{"title":"Files_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Files Source Code Files_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Files !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Useful tools to manipulate files in Fortran programs. !! Useful tools to manipulate files in Fortran programs. USE iso_c_binding IMPLICIT NONE PRIVATE PUBLIC :: mkdir , cp , mv , rm , exists , is_directory , is_empty , is_regular_file #ifdef LIN_CPP PUBLIC :: is_symlink , create_symlink #endif PUBLIC :: filesep , is_path_absolute , is_path_relative , extension , stem , filename , & parent_path #ifdef WIN_CPP CHARACTER , PARAMETER :: filesep = ACHAR ( 92 ) !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #elif LIN_CPP CHARACTER , PARAMETER :: filesep = '/' !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #else CHARACTER , PARAMETER :: filesep = '/' !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #endif INTERFACE FUNCTION c_createdir ( dir , ign ) RESULT ( res ) BIND ( c , name = 'c_createdir' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: dir LOGICAL ( C_BOOL ) :: ign LOGICAL ( C_BOOL ) :: res END FUNCTION c_createdir #ifdef LIN_CPP FUNCTION c_create_symlink ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_create_symlink' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), VALUE :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_create_symlink #endif FUNCTION c_copy_file ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_copy_file' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), VALUE :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_copy_file FUNCTION c_move_file ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_move_file' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), VALUE :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_move_file FUNCTION c_remove ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_remove' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_remove FUNCTION c_is_directory ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_directory' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_directory FUNCTION c_is_empty ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_empty' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_empty FUNCTION c_is_regular_file ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_regular_file' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_regular_file #ifdef LIN_CPP FUNCTION c_is_symlink ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_symlink' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_symlink #endif FUNCTION c_is_absolute ( fname ) RESULT ( res ) BIND ( c , name = 'c_is_absolute' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_absolute FUNCTION c_is_relative ( fname ) RESULT ( res ) BIND ( c , name = 'c_is_relative' ) USE iso_c_binding CHARACTER ( C_CHAR ), VALUE :: fname LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_relative SUBROUTINE c_extension ( fname ) BIND ( c , name = 'c_extension' ) USE iso_c_binding CHARACTER ( C_CHAR ) :: fname ( * ) END SUBROUTINE c_extension SUBROUTINE c_stem ( fname ) BIND ( c , name = 'c_stem' ) USE iso_c_binding CHARACTER ( C_CHAR ) :: fname ( * ) END SUBROUTINE c_stem SUBROUTINE c_filename ( fname ) BIND ( c , name = 'c_filename' ) USE iso_c_binding CHARACTER ( C_CHAR ) :: fname ( * ) END SUBROUTINE c_filename SUBROUTINE c_parent_path ( fname ) BIND ( c , name = 'c_parent_path' ) USE iso_c_binding CHARACTER ( C_CHAR ) :: fname ( * ) END SUBROUTINE c_parent_path END INTERFACE CONTAINS FUNCTION mkdir ( dir , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Creates a directory. !! Creates a directory. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: dir !! Path and name of the directory to be created. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_createdir ( dir // C_NULL_CHAR , ign ) END FUNCTION mkdir #ifdef LIN_CPP FUNCTION create_symlink ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Creates a symlink to a file or directory (Linux only). !! Creates a symlink to a file or directory (Linux only). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file or directory to be linked. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination link. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_create_symlink ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION create_symlink #endif FUNCTION cp ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Copies a file or directory. !! Copies a file or directory. Directories are copied recursively. !! Existing files are overwritten. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file to be copied. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination file. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_copy_file ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION cp FUNCTION mv ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Moves or renames a file or directory. !! Moves or renames a file or directory. When moving a directory if the !! destination is an already existing directory which is not empty an error is shown !! and nothing is done. The destination folder must be removed first using function rm. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file to be moved. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination file. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_move_file ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION mv FUNCTION rm ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Removes a file or directory. !! Removes a file or directory. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file or directory to be removed. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_remove ( fname // C_NULL_CHAR , ign ) END FUNCTION rm FUNCTION exists ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a file or directory exists. !! Checks if a file or directory exists. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be check for existence. LOGICAL :: res !! True if the file exists. False otherwise. INQUIRE ( FILE = fname , EXIST = res ) END FUNCTION exists FUNCTION is_directory ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a directory exists. !! Checks if a directory exists. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the directory to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a directory. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_directory ( fname // C_NULL_CHAR , ign ) END FUNCTION is_directory FUNCTION is_empty ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a file is empty. !! Checks if a file is empty. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is an empty file. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_empty ( fname // C_NULL_CHAR , ign ) END FUNCTION is_empty FUNCTION is_regular_file ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a regular file exists: it is not a directory, symlink, etc. !! Checks if a regular file exists: it is not a directory, symlink, etc. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a regular file. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_regular_file ( fname // C_NULL_CHAR , ign ) END FUNCTION is_regular_file #ifdef LIN_CPP FUNCTION is_symlink ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a symlink exists (Linux only). !! Checks if a symlink exists (Linux only). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the symlink to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a symlink. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_symlink ( fname // C_NULL_CHAR , ign ) END FUNCTION is_symlink #endif FUNCTION is_path_absolute ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if a path is absolute or not !! Determines if a path is absolute or not. Returns True if path is absolute !! and False if path is relative. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Path to a file. LOGICAL :: res !! True if the path is absolute and false if the path is relative. res = c_is_absolute ( fname // C_NULL_CHAR ) END FUNCTION is_path_absolute FUNCTION is_path_relative ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if a path is relative or not !! Determines if a path is relative or not. Returns True if path is relative !! and False if path is absolute. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Path to a file. LOGICAL :: res !! True if the path is relative and false if the path is absolute. res = c_is_relative ( fname // C_NULL_CHAR ) END FUNCTION is_path_relative FUNCTION extension ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the extension of a file. !! Determines the extension of a file given its name or path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Extension of the file including the \"dot\". Empty path is returned if no extension is found. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_extension ( c_string ) res = c_to_f ( c_string ) END FUNCTION extension FUNCTION stem ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the filename without the final extension given a path. !! Determines the filename without the final extension given a path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Filename without the final extension. If filename consists of an extension only, the !! extension is returned. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_stem ( c_string ) res = c_to_f ( c_string ) END FUNCTION stem FUNCTION filename ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the full filename given a path. !! Determines the full filename given a path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Full filename given in the path. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_filename ( c_string ) res = c_to_f ( c_string ) END FUNCTION filename FUNCTION parent_path ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the path to the parent directory given the path to a file. !! Determines the path to the parent directory given the path to a file. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Path of the parent directory without final slash. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_parent_path ( c_string ) res = c_to_f ( c_string ) END FUNCTION parent_path ! Auxiliary functions FUNCTION c_to_f ( c_string ) RESULT ( res ) ! Auxiliary function used as interface to convert c strings to fortran strings IMPLICIT NONE CHARACTER ( C_CHAR ) :: c_string CHARACTER ( LEN = :), ALLOCATABLE :: res INTEGER :: l !length l = 1 DO WHILE ( c_string ( l : l ) /= C_NULL_CHAR ) l = l + 1 END DO res = c_string ( 1 : l - 1 ) END FUNCTION c_to_f END MODULE FU_Files","tags":"","loc":"sourcefile/files_m.f90.html"},{"title":"Numbers_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Numbers Source Code Numbers_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Numbers !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Functions to analyze numbers in Fortran programs. !! Functions to analyze numbers in Fortran programs. Some of these functions (is_nan and is_inf) !! are now available in the intrinsics module IEEE_ARITHMETIC and !! are provided here only for compatibility with some old programs that use them. USE FU_Prec USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE PRIVATE PUBLIC :: is_nan , is_inf , count_digits_integer INTERFACE count_digits_integer !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Counts the number of digits of an integer. !! Counts the number of digits of an integer, including the - sign !! in case it is a negative value. MODULE PROCEDURE count_digits_integer_i8 MODULE PROCEDURE count_digits_integer_i16 MODULE PROCEDURE count_digits_integer_i32 MODULE PROCEDURE count_digits_integer_i64 END INTERFACE count_digits_integer INTERFACE is_nan !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if the value of the input variable is NaN. !! Determines if the value of the input variable is NaN. MODULE PROCEDURE is_nan_sp MODULE PROCEDURE is_nan_dp MODULE PROCEDURE is_nan_qp END INTERFACE is_nan INTERFACE is_inf !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if the value of the input variable is Infinity. !! Determines if the value of the input variable is NaN. MODULE PROCEDURE is_inf_sp MODULE PROCEDURE is_inf_dp MODULE PROCEDURE is_inf_qp END INTERFACE is_inf CONTAINS PURE FUNCTION count_digits_integer_i8 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i8 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i8 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i8 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i8 PURE FUNCTION count_digits_integer_i16 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i16 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i16 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i16 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i16 PURE FUNCTION count_digits_integer_i32 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i32 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i32 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i32 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i32 PURE FUNCTION count_digits_integer_i64 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i64 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i64 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i64 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i64 ELEMENTAL FUNCTION is_nan_sp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_sp ELEMENTAL FUNCTION is_nan_dp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_dp ELEMENTAL FUNCTION is_nan_qp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_qp ELEMENTAL FUNCTION is_inf_sp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_sp ELEMENTAL FUNCTION is_inf_dp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_dp ELEMENTAL FUNCTION is_inf_qp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_qp END MODULE FU_Numbers","tags":"","loc":"sourcefile/numbers_m.f90.html"},{"title":"include_covariance.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_covariance.f90 Source Code avg1 = mean ( x ) avg2 = mean ( y ) res = SUM (( x (:) - avg1 ) * ( y (:) - avg2 )) res = res / REAL ( SIZE ( x ) - 1 , prec )","tags":"","loc":"sourcefile/include_covariance.f90.html"},{"title":"include_lin_error_propagation.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_lin_error_propagation.f90 Source Code res = DOT_PRODUCT ( MATMUL ( sensitivities , matcovar ), sensitivities )","tags":"","loc":"sourcefile/include_lin_error_propagation.f90.html"},{"title":"include_gmean.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_gmean.f90 Source Code res = PRODUCT ( x ) ** ( 1._prec / REAL ( SIZE ( x ), prec ))","tags":"","loc":"sourcefile/include_gmean.f90.html"},{"title":"include_pskewness.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_pskewness.f90 Source Code avg = mean ( x ) sd = pstdev ( x ) n = SIZE ( x ) res = SUM (( x (:) - avg ) ** 3 ) / sd ** 3 / n","tags":"","loc":"sourcefile/include_pskewness.f90.html"},{"title":"include_skewness.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_skewness.f90 Source Code avg = mean ( x ) sd = stdev ( x ) n = SIZE ( x ) res = SUM (( x (:) - avg ) ** 3 ) / sd ** 3 * n / ( n - 1 ) / ( n - 2 )","tags":"","loc":"sourcefile/include_skewness.f90.html"},{"title":"include_correlation.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_correlation.f90 Source Code res = covariance ( x , y ) / stdev ( x ) / stdev ( y )","tags":"","loc":"sourcefile/include_correlation.f90.html"},{"title":"include_regression.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_regression.f90 Source Code SELECT CASE ( typeRegression ) CASE ( linreg_id ) x_cp = x y_cp = y CASE ( logreg_id ) x_cp = LOG ( x ) y_cp = y CASE ( expreg_id ) x_cp = x y_cp = LOG ( y ) CASE ( potreg_id ) x_cp = LOG10 ( x ) y_cp = LOG10 ( y ) END SELECT var_x = variance ( x_cp ) var_y = variance ( y_cp ) covar_xy = covariance ( x_cp , y_cp ) a = covar_xy / var_x SELECT CASE ( typeRegression ) CASE ( expreg_id ) b = EXP ( mean ( y_cp ) - a * mean ( x_cp )) CASE ( potreg_id ) b = 10 ** ( mean ( y_cp ) - a * mean ( x_cp )) CASE DEFAULT b = mean ( y_cp ) - a * mean ( x_cp ) END SELECT R2 = covar_xy ** 2 / var_x / var_y","tags":"","loc":"sourcefile/include_regression.f90.html"},{"title":"include_mean.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_mean.f90 Source Code res = SUM ( x ) / REAL ( SIZE ( x ), prec )","tags":"","loc":"sourcefile/include_mean.f90.html"},{"title":"include_variance.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_variance.f90 Source Code avg = mean ( x ) res = SUM (( x (:) - avg ) ** 2 ) res = res / REAL ( SIZE ( x ) - 1 , prec )","tags":"","loc":"sourcefile/include_variance.f90.html"},{"title":"include_num2strInt.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_num2strInt.f90 Source Code ALLOCATE ( character ( len = count_digits_integer ( num )) :: str ) WRITE ( str , formato ) num","tags":"","loc":"sourcefile/include_num2strint.f90.html"},{"title":"include_str2num.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_str2num.f90 Source Code IF (. FALSE .) res = mold !To disable compilation warning about unused variable READ ( str , * ) res","tags":"","loc":"sourcefile/include_str2num.f90.html"},{"title":"include_splitstr.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_splitstr.f90 Source Code IF ( PRESENT ( delimiter )) THEN d = delimiter ELSE d = ' ' END IF IF ( PRESENT ( mergedelim )) THEN IF ( mergedelim ) THEN res = mergeChars ( str , d ) ELSE res = str END IF ELSE res = str END IF IF ( PRESENT ( rev )) THEN IF ( rev ) THEN res = strReverse ( res ) END IF END IF ! If the delimiter is in the first positions of the string, remove it IF ( INDEX ( res , d ) == 1 ) THEN res = res ( LEN ( d ) + 1 :) END IF DO i = 1 , fieldNumber pos = INDEX ( res , d ) IF ( pos == 0 ) THEN IF ( i /= fieldNumber ) THEN res = '' END IF EXIT ELSE IF ( i == fieldNumber ) THEN res = res (: pos - 1 ) ELSE res = res ( pos + LEN ( d ):) END IF END DO IF ( PRESENT ( rev )) THEN IF ( rev ) THEN res = strReverse ( res ) END IF END IF","tags":"","loc":"sourcefile/include_splitstr.f90.html"},{"title":"include_int2str00000.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_int2str00000.f90 Source Code !Automatic allocation is not allowed in the write statements. ALLOCATE ( character ( len = total_length ) :: str ) WRITE ( str , '(I0.' // num2str ( total_length ) // ')' ) integ","tags":"","loc":"sourcefile/include_int2str00000.f90.html"},{"title":"include_num2strReal.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_num2strReal.f90 Source Code !adding the following statement in the allocate statement wihtout using !variable length is causing memory leaks in valgrind. Using length to !store the information fixes those memory leaks. IF ( startsWith ( formato , '(' )) THEN length = str2num ( splitstr ( formato ( 3 :), 1 , '.' ), 1_i16 ) ELSE length = str2num ( splitstr ( formato ( 2 :), 1 , '.' ), 1_i16 ) END IF ALLOCATE ( character ( len = length ) :: str ) WRITE ( str , '(' // formato // ')' ) num","tags":"","loc":"sourcefile/include_num2strreal.f90.html"},{"title":"include_count_digits_integer.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_count_digits_integer.f90 Source Code IF ( i < 0 ) THEN num_digits = two ELSE num_digits = one END IF integ = ABS ( i ) integ = integ / ten DO WHILE ( integ /= 0 ) num_digits = num_digits + one integ = integ / ten END DO","tags":"","loc":"sourcefile/include_count_digits_integer.f90.html"},{"title":"ResetTotalTime – ecasglez's FortranUtilities","text":"public subroutine ResetTotalTime() Sets the starting point to count the total time. Arguments None Contents None","tags":"","loc":"proc/resettotaltime.html"},{"title":"TotalTime – ecasglez's FortranUtilities","text":"public interface TotalTime TotalTime gets the time in seconds (with a precision of microseconds)\n since the beginning of the program or since the last time resetTotalTime is executed. You can use mold input argument to indicate the precision of the output number. Default precision\n is the default precision of your compiler. Contents Module Procedures TotalTime_def TotalTime_sp TotalTime_dp Module Procedures private function TotalTime_def() result(res) Arguments None Return Value real Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses default precision of the compiler used. private function TotalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. private function TotalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold.","tags":"","loc":"interface/totaltime.html"},{"title":"IntervalTime – ecasglez's FortranUtilities","text":"public interface IntervalTime IntervalTime gets the time in seconds (with a precision of microseconds) \n since the last measurement or the time since the begining of the execution if no previous \n measuement is available. This point will be used as a starting point for the next interval. You can use mold input argument to indicate the precision of the output number. Default precision\n is the default precision of your compiler. Contents Module Procedures IntervalTime_def IntervalTime_sp IntervalTime_dp Module Procedures private function IntervalTime_def() result(res) Arguments None Return Value real Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses default precision of the compiler used. private function IntervalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. private function IntervalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold.","tags":"","loc":"interface/intervaltime.html"},{"title":"mergeChars – ecasglez's FortranUtilities","text":"public pure function mergeChars(str, c) result(res) Merge characters in a string if they are contiguous. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to search inside for contiguous duplicated characters. character(len=*), intent(in) :: c Character to search for contiguous duplications. Return Value character(len=:),\n  ALLOCATABLE String with the selected character contiguous duplications removed. Contents None","tags":"","loc":"proc/mergechars.html"},{"title":"startsWith – ecasglez's FortranUtilities","text":"public elemental function startsWith(str, substr) result(res) Checks if a string starts with a given substring. It can be an array of string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it starts. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str starts with it. Return Value logical True if the string starts with the substring and False otherwise. If\n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. Contents None","tags":"","loc":"proc/startswith.html"},{"title":"endsWith – ecasglez's FortranUtilities","text":"public elemental function endsWith(str, substr) result(res) Checks if a string ends with a given substring. It can be an array of string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it ends. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str ends with it. Return Value logical True if the string ends with the substring and False otherwise. If \n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. Contents None","tags":"","loc":"proc/endswith.html"},{"title":"replace – ecasglez's FortranUtilities","text":"public pure function replace(str, search, repla) result(res) Searches and replaces a substring in a string. It replaces \n all occurences. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to modify character(len=*), intent(in) :: search String to search in str. character(len=*), intent(in) :: repla String to replace in str. Return Value character(len=:),\n  ALLOCATABLE Modified string. Contents None","tags":"","loc":"proc/replace.html"},{"title":"upper – ecasglez's FortranUtilities","text":"public pure function upper(str) result(res) Converts a string to uppercase characters. It works with this dataset:\n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to uppercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to uppercase characters. Contents None","tags":"","loc":"proc/upper.html"},{"title":"lower – ecasglez's FortranUtilities","text":"public pure function lower(str) result(res) Converts a string to lowercase characters. It works with this dataset\n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to lowercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to lowercase characters. Contents None","tags":"","loc":"proc/lower.html"},{"title":"cistrcmp – ecasglez's FortranUtilities","text":"public pure function cistrcmp(str1, str2) result(res) Case-independent string comparison. It works with this dataset: \n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 First string to compare. character(len=*), intent(in) :: str2 Second string to compare Return Value logical True if both strings are equal independently of the case. False otherwise. Contents None","tags":"","loc":"proc/cistrcmp.html"},{"title":"splitstr – ecasglez's FortranUtilities","text":"public interface splitstr Splits a string and returns the portion selected by the user. Contents Module Procedures splitstr_i8 splitstr_i16 splitstr_i32 splitstr_i64 Module Procedures private pure function splitstr_i8(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i8), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i16(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i16), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i32(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i32), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i64(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i64), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string.","tags":"","loc":"interface/splitstr.html"},{"title":"num2str – ecasglez's FortranUtilities","text":"public interface num2str Converts an integer or real variable into a string variable.\n Useful to open files named sequentially. Contents Module Procedures num2str_i8 num2str_i16 num2str_i32 num2str_i64 num2str_sp num2str_dp num2str_qp Module Procedures private pure function num2str_i8(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i16(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i32(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i64(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_sp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_dp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_qp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number","tags":"","loc":"interface/num2str.html"},{"title":"int2str00000 – ecasglez's FortranUtilities","text":"public interface int2str00000 Converts an integer variable into a string variable,\n filling with leading zeros up to the limit imposed by the user.\n Useful to open files named sequentially with leading zeros in the name. Contents Module Procedures int2str00000_i8 int2str00000_i16 int2str00000_i32 int2str00000_i64 Module Procedures private pure function int2str00000_i8(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i8), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i16(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i16), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i32(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i32), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i64(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i64), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number.","tags":"","loc":"interface/int2str00000.html"},{"title":"str2num – ecasglez's FortranUtilities","text":"public interface str2num Converts a string into an integer or real number as specified by the type of variable mold. Contents Module Procedures str2num_i8 str2num_i16 str2num_i32 str2num_i64 str2num_sp str2num_dp str2num_qp Module Procedures private pure function str2num_i8(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i8), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i8) The number of the input string. private pure function str2num_i16(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i16), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i16) The number of the input string. private pure function str2num_i32(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i32), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i32) The number of the input string. private pure function str2num_i64(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i64), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i64) The number of the input string. private pure function str2num_sp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=sp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=sp) The number of the input string. private pure function str2num_dp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=dp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=dp) The number of the input string. private pure function str2num_qp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=qp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=qp) The number of the input string.","tags":"","loc":"interface/str2num.html"},{"title":"mean – ecasglez's FortranUtilities","text":"public interface mean Calculates the mean value of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = mean(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the mean value of x . Contents Module Procedures mean_sp mean_dp mean_qp Module Procedures private pure function mean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the average of x. private pure function mean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the average of x. private pure function mean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the average of x.","tags":"","loc":"interface/mean.html"},{"title":"gmean – ecasglez's FortranUtilities","text":"public interface gmean Calculates the geometric mean of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = gmean(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the geometric mean of x . Contents Module Procedures gmean_sp gmean_dp gmean_qp Module Procedures private pure function gmean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the geometric mean of the x. private pure function gmean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the geometric mean of the x. private pure function gmean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the geometric mean of the x.","tags":"","loc":"interface/gmean.html"},{"title":"variance – ecasglez's FortranUtilities","text":"public interface variance Calculates the sample variance of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = variance(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample variance of x . Contents Module Procedures variance_sp variance_dp variance_qp Module Procedures private pure function variance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample variance of x. private pure function variance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample variance of x. private pure function variance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample variance of x.","tags":"","loc":"interface/variance.html"},{"title":"stdev – ecasglez's FortranUtilities","text":"public interface stdev Calculates the sample standard deviation of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = stdev(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample standard deviation of x . Contents Module Procedures stdev_sp stdev_dp stdev_qp Module Procedures private pure function stdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample standard deviation of x. private pure function stdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample standard deviation of x. private pure function stdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample standard deviation of x.","tags":"","loc":"interface/stdev.html"},{"title":"pvariance – ecasglez's FortranUtilities","text":"public interface pvariance Calculates the population variance of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pvariance(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population variance of x . Contents Module Procedures pvariance_sp pvariance_dp pvariance_qp Module Procedures private pure function pvariance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the variance of x. private pure function pvariance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the variance of x. private pure function pvariance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the variance of x.","tags":"","loc":"interface/pvariance.html"},{"title":"pstdev – ecasglez's FortranUtilities","text":"public interface pstdev Calculates the population standard deviation of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pstdev(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population standard deviation of x . Contents Module Procedures pstdev_sp pstdev_dp pstdev_qp Module Procedures private pure function pstdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population standard deviation of x. private pure function pstdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population standard deviation of x. private pure function pstdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population standard deviation of x.","tags":"","loc":"interface/pstdev.html"},{"title":"covariance – ecasglez's FortranUtilities","text":"public interface covariance Calculates the sample covariance between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = covariance(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the sample covariance of x and y . Contents Module Procedures covariance_sp covariance_dp covariance_qp Module Procedures private pure function covariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample covariance between both variables. private pure function covariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample covariance between both variables. private pure function covariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample covariance between both variables.","tags":"","loc":"interface/covariance.html"},{"title":"pcovariance – ecasglez's FortranUtilities","text":"public interface pcovariance Calculates the population covariance between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = pcovariance(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the population covariance of x and y . Contents Module Procedures pcovariance_sp pcovariance_dp pcovariance_qp Module Procedures private pure function pcovariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function pcovariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function pcovariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables.","tags":"","loc":"interface/pcovariance.html"},{"title":"correlation – ecasglez's FortranUtilities","text":"public interface correlation Calculates the correlation coefficient between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = correlation(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the correlation coefficient of x and y . Contents Module Procedures correlation_sp correlation_dp correlation_qp Module Procedures private pure function correlation_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function correlation_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function correlation_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables.","tags":"","loc":"interface/correlation.html"},{"title":"lin_error_propagation – ecasglez's FortranUtilities","text":"public interface lin_error_propagation Performs linear error (or uncertainties) propagation given the\n sensitivity coefficients and a covariance matrix. The following\n formula is applied: where: is the response whose uncertainty is to be calculated. is a set of input parameters to propagate their uncertainty to . is the vector of sensitivity coefficients of with respect to the\n   different parameters in . is the covariance matrix of the parameters in . Usage: y = lin_error_propagation(s,m) where: s = vector of rank 1 with real numbers containing the sensitivity coefficients. m = array of rank 2 containing the covariance matrix. y = real number of the same kind as s and m with the\n error or uncertainty propagated to this new variable. Contents Module Procedures lin_error_propagation_sp lin_error_propagation_dp lin_error_propagation_qp Module Procedures private pure function lin_error_propagation_sp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=sp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_dp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=dp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_qp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=qp) Real number with the error or uncertainty (variance) propagated to the new variable.","tags":"","loc":"interface/lin_error_propagation.html"},{"title":"median – ecasglez's FortranUtilities","text":"public interface median Calculates the median value.\n This function does not work with quadruple precision numbers\n because of the ordering subroutine written in C++. Usage: y = median(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the median of x . Contents Module Procedures median_sp median_dp Module Procedures private function median_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the median private function median_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the median","tags":"","loc":"interface/median.html"},{"title":"skewness – ecasglez's FortranUtilities","text":"public interface skewness Calculates the sample skewness of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = skewness(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample skewness of x . Contents Module Procedures skewness_sp skewness_dp skewness_qp Module Procedures private pure function skewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample skewness of the x. private pure function skewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample skewness of the x. private pure function skewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample skewness of the x.","tags":"","loc":"interface/skewness.html"},{"title":"pskewness – ecasglez's FortranUtilities","text":"public interface pskewness Calculates the population skewness of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pskewness(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population skewness of x . Contents Module Procedures pskewness_sp pskewness_dp pskewness_qp Module Procedures private pure function pskewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population skewness of the x. private pure function pskewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population skewness of the x. private pure function pskewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population skewness of the x.","tags":"","loc":"interface/pskewness.html"},{"title":"linreg – ecasglez's FortranUtilities","text":"public interface linreg Performs linear regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to measure the goodness of fit. Usage: CALL linreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures linreg_sp linreg_dp linreg_qp Module Procedures private subroutine linreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine linreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine linreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/linreg.html"},{"title":"logreg – ecasglez's FortranUtilities","text":"public interface logreg Performs logarithmic regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL logreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures logreg_sp logreg_dp logreg_qp Module Procedures private subroutine logreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine logreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine logreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/logreg.html"},{"title":"expreg – ecasglez's FortranUtilities","text":"public interface expreg Performs exponential regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL expreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures expreg_sp expreg_dp expreg_qp Module Procedures private subroutine expreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine expreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine expreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/expreg.html"},{"title":"potreg – ecasglez's FortranUtilities","text":"public interface potreg Performs potential regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL potreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures potreg_sp potreg_dp potreg_qp Module Procedures private subroutine potreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine potreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine potreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/potreg.html"},{"title":"mkdir – ecasglez's FortranUtilities","text":"public function mkdir(dir, ignoreErrors) result(res) Creates a directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Path and name of the directory to be created. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message.\n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/mkdir.html"},{"title":"cp – ecasglez's FortranUtilities","text":"public function cp(src, dest, ignoreErrors) result(res) Copies a file or directory. Directories are copied recursively.\n Existing files are overwritten. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be copied. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/cp.html"},{"title":"mv – ecasglez's FortranUtilities","text":"public function mv(src, dest, ignoreErrors) result(res) Moves or renames a file or directory. When moving a directory if the \n destination is an already existing directory which is not empty an error is shown\n and nothing is done. The destination folder must be removed first using function rm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be moved. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/mv.html"},{"title":"rm – ecasglez's FortranUtilities","text":"public function rm(fname, ignoreErrors) result(res) Removes a file or directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file or directory to be removed. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/rm.html"},{"title":"exists – ecasglez's FortranUtilities","text":"public function exists(fname) result(res) Checks if a file or directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be check for existence. Return Value logical True if the file exists. False otherwise. Contents None","tags":"","loc":"proc/exists.html"},{"title":"is_directory – ecasglez's FortranUtilities","text":"public function is_directory(fname, ignoreErrors) result(res) Checks if a directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the directory to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a directory. False otherwise. Contents None","tags":"","loc":"proc/is_directory.html"},{"title":"is_empty – ecasglez's FortranUtilities","text":"public function is_empty(fname, ignoreErrors) result(res) Checks if a file is empty. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is an empty file. False otherwise. Contents None","tags":"","loc":"proc/is_empty.html"},{"title":"is_regular_file – ecasglez's FortranUtilities","text":"public function is_regular_file(fname, ignoreErrors) result(res) Checks if a regular file exists: it is not a directory, symlink, etc. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a regular file. False otherwise. Contents None","tags":"","loc":"proc/is_regular_file.html"},{"title":"is_path_absolute – ecasglez's FortranUtilities","text":"public function is_path_absolute(fname) result(res) Determines if a path is absolute or not. Returns True if path is absolute\n and False if path is relative. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is absolute and false if the path is relative. Contents None","tags":"","loc":"proc/is_path_absolute.html"},{"title":"is_path_relative – ecasglez's FortranUtilities","text":"public function is_path_relative(fname) result(res) Determines if a path is relative or not. Returns True if path is relative\n and False if path is absolute. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is relative and false if the path is absolute. Contents None","tags":"","loc":"proc/is_path_relative.html"},{"title":"extension – ecasglez's FortranUtilities","text":"public function extension(fname) result(res) Determines the extension of a file given its name or path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Extension of the file including the \"dot\". Empty path is returned if no extension is found. Contents None","tags":"","loc":"proc/extension.html"},{"title":"stem – ecasglez's FortranUtilities","text":"public function stem(fname) result(res) Determines the filename without the final extension given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Filename without the final extension. If filename consists of an extension only, the\n extension is returned. Contents None","tags":"","loc":"proc/stem.html"},{"title":"filename – ecasglez's FortranUtilities","text":"public function filename(fname) result(res) Determines the full filename given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Full filename given in the path. Contents None","tags":"","loc":"proc/filename.html"},{"title":"parent_path – ecasglez's FortranUtilities","text":"public function parent_path(fname) result(res) Determines the path to the parent directory given the path to a file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Path of the parent directory without final slash. Contents None","tags":"","loc":"proc/parent_path.html"},{"title":"count_digits_integer – ecasglez's FortranUtilities","text":"public interface count_digits_integer Counts the number of digits of an integer, including the - sign \n in case it is a negative value. Contents Module Procedures count_digits_integer_i8 count_digits_integer_i16 count_digits_integer_i32 count_digits_integer_i64 Module Procedures private pure function count_digits_integer_i8(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i8) The number of digits of the input number. private pure function count_digits_integer_i16(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i16) The number of digits of the input number. private pure function count_digits_integer_i32(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i32) The number of digits of the input number. private pure function count_digits_integer_i64(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i64) The number of digits of the input number.","tags":"","loc":"interface/count_digits_integer.html"},{"title":"is_nan – ecasglez's FortranUtilities","text":"public interface is_nan Determines if the value of the input variable is NaN. Contents Module Procedures is_nan_sp is_nan_dp is_nan_qp Module Procedures private elemental function is_nan_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value.","tags":"","loc":"interface/is_nan.html"},{"title":"is_inf – ecasglez's FortranUtilities","text":"public interface is_inf Determines if the value of the input variable is NaN. Contents Module Procedures is_inf_sp is_inf_dp is_inf_qp Module Procedures private elemental function is_inf_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value.","tags":"","loc":"interface/is_inf.html"},{"title":"FU_Prec – ecasglez's FortranUtilities","text":"Precision parameters to use in Fortran programs with real or integer variable types. Uses iso_fortran_env Contents Variables sp dp qp i8 i16 i32 i64 Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = REAL32 Kind parameter to specify a real type with a storage size of 32 bits. integer, public, parameter :: dp = REAL64 Kind parameter to specify a real type with a storage size of 64 bits. integer, public, parameter :: qp = REAL128 Kind parameter to specify a real type with a storage size of 128 bits. integer, public, parameter :: i8 = INT8 Kind parameter to specify an integer type with a storage size of 8 bits. integer, public, parameter :: i16 = INT16 Kind parameter to specify an integer type with a storage size of 16 bits. integer, public, parameter :: i32 = INT32 Kind parameter to specify an integer type with a storage size of 32 bits. integer, public, parameter :: i64 = INT64 Kind parameter to specify an integer type with a storage size of 64 bits.","tags":"","loc":"module/fu_prec.html"},{"title":"FU_Timing – ecasglez's FortranUtilities","text":"Tools to measure time spent by functions in Fortran programs.\n The user can use IntervalTime to get the time since the last measure or the time\n since the begining of the execution if no previous measuement is available. This point\n will be used as a starting point for the next interval.\n Use TotalTime to get the time since the beginning of the program or since the last time\n resetTotalTime is executed. Uses FU_Prec Contents Interfaces TotalTime IntervalTime Subroutines ResetTotalTime Interfaces public interface TotalTime Gets the time in seconds since the beginning of the program or since the last time resetTotalTime is executed. Read more… private function TotalTime_def() result(res) Arguments None Return Value real Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses default precision of the compiler used. private function TotalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. private function TotalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. public interface IntervalTime Gets the time in seconds since the last measurement. Read more… private function IntervalTime_def() result(res) Arguments None Return Value real Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses default precision of the compiler used. private function IntervalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. private function IntervalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. Subroutines public subroutine ResetTotalTime () Author Emilio Castro. Date 10/09/2020. License MIT. Version 1.0. Sets the starting point to count the total time. Arguments None","tags":"","loc":"module/fu_timing.html"},{"title":"FU_Strings – ecasglez's FortranUtilities","text":"Useful tools to manipulate strings in Fortran programs. Uses FU_Prec Contents Interfaces splitstr num2str int2str00000 str2num Functions mergeChars startsWith endsWith replace upper lower cistrcmp Interfaces public interface splitstr Splits a string. Read more… private pure function splitstr_i8(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i8), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i16(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i16), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i32(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i32), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i64(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i64), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. public interface num2str Converts number into a string. Read more… private pure function num2str_i8(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i16(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i32(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i64(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_sp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_dp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_qp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number public interface int2str00000 Converts an integer into a string filling with leading zeros. Read more… private pure function int2str00000_i8(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i8), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i16(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i16), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i32(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i32), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i64(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i64), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. public interface str2num Converts a string into an integer or real. Read more… private pure function str2num_i8(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i8), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i8) The number of the input string. private pure function str2num_i16(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i16), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i16) The number of the input string. private pure function str2num_i32(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i32), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i32) The number of the input string. private pure function str2num_i64(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i64), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i64) The number of the input string. private pure function str2num_sp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=sp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=sp) The number of the input string. private pure function str2num_dp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=dp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=dp) The number of the input string. private pure function str2num_qp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=qp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=qp) The number of the input string. Functions public pure function mergeChars (str, c) result(res) Author Emilio Castro. Date 14/08/2020. License MIT. Version 1.0. Merge characters in a string if they are contiguous. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to search inside for contiguous duplicated characters. character(len=*), intent(in) :: c Character to search for contiguous duplications. Return Value character(len=:),\n  ALLOCATABLE String with the selected character contiguous duplications removed. public elemental function startsWith (str, substr) result(res) Author Emilio Castro. Date 07/05/2020. License MIT. Version 1.0. Checks if a string starts with a given substring. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it starts. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str starts with it. Return Value logical True if the string starts with the substring and False otherwise. If\n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. public elemental function endsWith (str, substr) result(res) Author Emilio Castro. Date 07/05/2020. License MIT. Version 1.0. Checks if a string ends with a given substring. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it ends. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str ends with it. Return Value logical True if the string ends with the substring and False otherwise. If \n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. public pure function replace (str, search, repla) result(res) Author Emilio Castro. Date 10/07/2020. License MIT. Version 1.0. Searches and replaces a substring in a string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to modify character(len=*), intent(in) :: search String to search in str. character(len=*), intent(in) :: repla String to replace in str. Return Value character(len=:),\n  ALLOCATABLE Modified string. public pure function upper (str) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Converts a string to uppercase characters. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to uppercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to uppercase characters. public pure function lower (str) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Converts a string to lowercase characters. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to lowercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to lowercase characters. public pure function cistrcmp (str1, str2) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Case-independent string comparison. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 First string to compare. character(len=*), intent(in) :: str2 Second string to compare Return Value logical True if both strings are equal independently of the case. False otherwise.","tags":"","loc":"module/fu_strings.html"},{"title":"FU_Statistics – ecasglez's FortranUtilities","text":"Statistics tools for Fortran programs. Uses FU_Prec Contents Interfaces mean gmean variance stdev pvariance pstdev covariance pcovariance correlation lin_error_propagation median skewness pskewness linreg logreg expreg potreg Interfaces public interface mean Calculates the mean value. Read more… private pure function mean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the average of x. private pure function mean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the average of x. private pure function mean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the average of x. public interface gmean Calculates the geometric mean. Read more… private pure function gmean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the geometric mean of the x. private pure function gmean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the geometric mean of the x. private pure function gmean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the geometric mean of the x. public interface variance Calculates the sample variance. Read more… private pure function variance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample variance of x. private pure function variance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample variance of x. private pure function variance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample variance of x. public interface stdev Calculates the sample standard deviation. Read more… private pure function stdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample standard deviation of x. private pure function stdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample standard deviation of x. private pure function stdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample standard deviation of x. public interface pvariance Calculates the population variance. Read more… private pure function pvariance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the variance of x. private pure function pvariance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the variance of x. private pure function pvariance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the variance of x. public interface pstdev Calculates the population standard deviation. Read more… private pure function pstdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population standard deviation of x. private pure function pstdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population standard deviation of x. private pure function pstdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population standard deviation of x. public interface covariance Calculates the sample covariance between two variables. Read more… private pure function covariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample covariance between both variables. private pure function covariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample covariance between both variables. private pure function covariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample covariance between both variables. public interface pcovariance Calculates the population covariance between two variables. Read more… private pure function pcovariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function pcovariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function pcovariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables. public interface correlation Calculates the correlation coefficient between two variables. Read more… private pure function correlation_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function correlation_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function correlation_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables. public interface lin_error_propagation Performs linear error (or uncertainties) propagation. Read more… private pure function lin_error_propagation_sp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=sp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_dp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=dp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_qp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=qp) Real number with the error or uncertainty (variance) propagated to the new variable. public interface median Calculates the median value. Read more… private function median_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the median private function median_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the median public interface skewness Calculates the sample skewness of a set of values. Read more… private pure function skewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample skewness of the x. private pure function skewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample skewness of the x. private pure function skewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample skewness of the x. public interface pskewness Calculates the population skewness of a set of values. Read more… private pure function pskewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population skewness of the x. private pure function pskewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population skewness of the x. private pure function pskewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population skewness of the x. public interface linreg Performs linear regression between two sets of values. Read more… private subroutine linreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine linreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine linreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface logreg Performs logarithmic regression between two sets of values. Read more… private subroutine logreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine logreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine logreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface expreg Performs exponential regression between two sets of values. Read more… private subroutine expreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine expreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine expreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface potreg Performs potential regression between two sets of values. Read more… private subroutine potreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine potreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine potreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"module/fu_statistics.html"},{"title":"FU_Files – ecasglez's FortranUtilities","text":"Useful tools to manipulate files in Fortran programs. Uses iso_c_binding Contents Variables filesep Functions mkdir cp mv rm exists is_directory is_empty is_regular_file is_path_absolute is_path_relative extension stem filename parent_path Variables Type Visibility Attributes Name Initial character, public, parameter :: filesep = '/' Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. Functions public function mkdir (dir, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Creates a directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Path and name of the directory to be created. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message.\n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function cp (src, dest, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Copies a file or directory. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be copied. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function mv (src, dest, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Moves or renames a file or directory. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be moved. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function rm (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Removes a file or directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file or directory to be removed. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function exists (fname) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a file or directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be check for existence. Return Value logical True if the file exists. False otherwise. public function is_directory (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the directory to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a directory. False otherwise. public function is_empty (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a file is empty. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is an empty file. False otherwise. public function is_regular_file (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a regular file exists: it is not a directory, symlink, etc. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a regular file. False otherwise. public function is_path_absolute (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines if a path is absolute or not Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is absolute and false if the path is relative. public function is_path_relative (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines if a path is relative or not Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is relative and false if the path is absolute. public function extension (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines the extension of a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Extension of the file including the \"dot\". Empty path is returned if no extension is found. public function stem (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the filename without the final extension given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Filename without the final extension. If filename consists of an extension only, the\n extension is returned. public function filename (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the full filename given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Full filename given in the path. public function parent_path (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the path to the parent directory given the path to a file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Path of the parent directory without final slash.","tags":"","loc":"module/fu_files.html"},{"title":"FU_Numbers – ecasglez's FortranUtilities","text":"Functions to analyze numbers in Fortran programs. Some of these functions (is_nan and is_inf)\n are now available in the intrinsics module IEEE_ARITHMETIC and\n are provided here only for compatibility with some old programs that use them. Uses ieee_arithmetic FU_Prec Contents Interfaces count_digits_integer is_nan is_inf Interfaces public interface count_digits_integer Counts the number of digits of an integer. Read more… private pure function count_digits_integer_i8(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i8) The number of digits of the input number. private pure function count_digits_integer_i16(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i16) The number of digits of the input number. private pure function count_digits_integer_i32(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i32) The number of digits of the input number. private pure function count_digits_integer_i64(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i64) The number of digits of the input number. public interface is_nan Determines if the value of the input variable is NaN. private elemental function is_nan_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. public interface is_inf Determines if the value of the input variable is Infinity. Read more… private elemental function is_inf_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value.","tags":"","loc":"module/fu_numbers.html"},{"title":"General documentation – ecasglez's FortranUtilities","text":"Only examples are included yet","tags":"","loc":"page//index.html"},{"title":"Compilation – ecasglez's FortranUtilities","text":"To do. See the main page or README.md for more information in the meantime","tags":"","loc":"page/Compilation/index.html"},{"title":"Examples – ecasglez's FortranUtilities","text":"Some examples are collected in this pages. The only requirement is to have ecasglez's FortranUtilities compiled.","tags":"","loc":"page/Examples/index.html"},{"title":"Timing and Statistics usage (with OpenMP) – ecasglez's FortranUtilities","text":"Description This example illustrate the use of FU_Prec , FU_Statistics and FU_Timing modules using a simple program. It generates a set of random numbers and then performs a lot of mean, variance and median calculations, and measures the time needed with different number of threads (using OpenMP). Uses up to 7 OpenMP threads. Change this parameter accordingly. Functions used FU_Prec . dp FU_Statistics . mean variance median FU_Timing . ResetTotalTime IntervalTime TotalTime Code PROGRAM FU_example1 ! Example program for FU_Prec, FU_Statistics and FU_Timing modules of ecasglez's FortranUtilities. ! It repeats a lot of mean, variance and median calculations using random numbers. ! Uses OpenMP for parallel execution. ! compile using: gfortran example1.f90 -o example1 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 ! before running: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} ! run using: ./example1 ! license: MIT. !$   USE omp_lib USE FU_Prec , ONLY : dp USE FU_statistics , ONLY : mean , variance , median USE FU_Timing , ONLY : resetTotalTime , IntervalTIme , TotalTime IMPLICIT NONE INTEGER , PARAMETER :: max_num_threads = 7 INTEGER , PARAMETER :: n = 1000 REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: matrix REAL ( KIND = dp ), DIMENSION ( n ) :: media , varianza , mediana INTEGER :: i , k ALLOCATE ( matrix ( 300000 , n )) DO i = 1 , n CALL random_number ( matrix (:, i )) END DO CALL resetTotalTime () DO k = 1 , max_num_threads !$    CALL omp_set_num_threads(k) !$OMP PARALLEL DO DO i = 1 , n media ( i ) = mean ( matrix (:, i )) varianza ( i ) = variance ( matrix (:, i )) mediana ( i ) = median ( matrix (:, i )) END DO !$OMP END PARALLEL DO WRITE ( * , '(A,I0,A,F7.3,A)' ) 'Number of threads: ' , k , '. Elapsed time: ' , IntervalTime (), ' s.' END DO WRITE ( * , '(A,F7.3,A)' ) 'Total elapsed time: ' , TotalTime (), ' s.' DEALLOCATE ( matrix ) END PROGRAM FU_example1 Compilation Compile using the following command. Adjust paths accordingly. gfortran example1.f90 -o example1 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 If no OpenMP libraries are available in your system, you can remove option -fopenmp . The code will work but there will not be any speedup. Execution Before running, since it has been compiled against the shared library: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} Then run with: ./example1 The output of the execution is: Number of threads: 1. Time spent:  22.010 s.\nNumber of threads: 2. Time spent:  11.440 s.\nNumber of threads: 3. Time spent:   8.107 s.\nNumber of threads: 4. Time spent:   6.113 s.\nNumber of threads: 5. Time spent:   5.887 s.\nNumber of threads: 6. Time spent:   4.987 s.\nNumber of threads: 7. Time spent:   4.452 s.\nTotal time spent:  62.995 s.","tags":"","loc":"page/Examples/Example01/index.html"},{"title":"Calculate mean value of a rank 3 array. – ecasglez's FortranUtilities","text":"Description This example illustrate the use of FU_Prec and FU_Statistics modules using a simple program. It generates an array with rank 3 filled with random numbers showing 3 examples on how to apply function mean (or any other function from FU_Statistics ) to an array of size larger than 1. Functions used FU_Prec . dp FU_Statistics . mean Code PROGRAM FU_example2 ! Example program for FU_Prec and FU_Statistics modules of ecasglez's FortranUtilities, ! showing how to apply FU_Statistics functions to an array with rank larger than 1. ! It shows 3 examples on how to calculate the mean value of a rank 3 array. ! compile using: gfortran example2.f90 -o example2 -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 ! before running: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} ! run using: ./example2 ! license: MIT. USE FU_Prec , ONLY : dp USE FU_statistics , ONLY : mean IMPLICIT NONE INTEGER , PARAMETER :: n = 100 REAL ( KIND = 8 ), DIMENSION (:,:,:), ALLOCATABLE :: matrix REAL ( KIND = 8 ) :: media ALLOCATE ( matrix ( n , n , n )) CALL random_number ( matrix (:,:,:)) !First method. Use RESHAPE. media = mean ( RESHAPE ( matrix ,([ SIZE ( matrix )]))) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' !Second method. Use an array constructor. media = mean ([ matrix ]) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' !Third method. Use sequence association. Use auxiliary function mean3D (see below) media = mean3D ( matrix , SIZE ( matrix )) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' DEALLOCATE ( matrix ) CONTAINS FUNCTION mean3D ( a , n ) RESULT ( res ) USE FU_statistics , ONLY : mean IMPLICIT NONE REAL ( KIND = dp ), DIMENSION ( n ), INTENT ( IN ) :: a INTEGER , INTENT ( IN ) :: n REAL ( KIND = dp ) :: res res = mean ( a ) END FUNCTION mean3D END PROGRAM FU_example2 Compilation Compile using the following command. Adjust paths accordingly. gfortran example2.f90 -o example2 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 Execution Before running, since it has been compiled against the shared library: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} Then run with: ./example2 The output of the execution is: Mean value:   0.50046.\nMean value:   0.50046.\nMean value:   0.50046.","tags":"","loc":"page/Examples/Example02/index.html"}]}