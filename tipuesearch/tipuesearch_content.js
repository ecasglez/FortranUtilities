var tipuesearch = {"pages":[{"title":" ecasglez's FortranUtilities ","text":"ecasglez's FortranUtilities Note This is Work-in-Progress. More functions are being added. ecasglez's FortranUtilities is a collection of simple functions for Fortran programs. Functions for strings, numbers, precision, statistics and files are included. See the specifications of the different functions. More functions for different tasks will be included in the future. This is a BETA version. All functions work properly on Linux using gfortran 7.5 or newer, and all functions except symlink functions work on Windows using gfortran 7.5 (MSYS2-Mingw-w64) or newer. More compilers will be tested in the future. Downloading The latest version of this library can be obtained from the GitHub repository located here . Compilation Check that you have cmake version 3.10 or newer, a Fortran compiler compatible with Fortran 2008, and a C++ compiler compatible with C++17. Download the files and enter directory FortranUtilities. Then create a build directory and enter that directory: mkdir build cd build Type: cmake .. Optionally you can select an install directory by typing: cmake .. -DCMAKE_INSTALL_PREFIX=/installation/path/ On Windows using MSYS2-Mingw-w64 use: cmake .. -G \"MinGW Makefiles\" Compile: make On Windows using MSYS2-Mingw-w64 use instead of make: mingw32-make.exe Install: make install A static and and a shared library are created. Test programs for both libraries are created too. Documentation Documentation of the different functions is here . Usage To use the library in your programs you first need to use the module of interest, as in the following example: PROGRAM test USE FU_Strings WRITE ( * , * ) int2str ( 5 ) END PROGRAM test Then you have to link to the library when compiling. For example: To use the static library: gfortran program.f90 -o program -lFortranUtilitiesStatic -L/path/to/the/library/folder -I/path/to/include/folder -lstdc++ To use the shared library: gfortran program.f90 -lFortranUtilities -L/path/to/the/library/folder -I/path/to/include/folder Contact Developed by Emilio Castro. Create a Issue in GitHub if you have any suggestion, comment, enhancement, bug, etc. License These files are distributed under a MIT license. See LICENSE file for more information on using and distributing these files. Developer Info Emilio Castro","tags":"home","loc":"index.html"},{"title":"Strings_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Strings Source Code Strings_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Strings !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Useful tools to manipulate strings in Fortran programs. !! Useful tools to manipulate strings in Fortran programs. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: num2str , int2str00000 , str2num PUBLIC :: startsWith , endsWith , splitstr , replace , mergeChars PUBLIC :: upper , lower , cistrcmp CHARACTER ( LEN =* ), PARAMETER :: lowercase = 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' CHARACTER ( LEN =* ), PARAMETER :: uppercase = 'AÁÄÀÂBCDEÉËÈÊFGHIÍÏÌÎJKLMNÑOÓÖÒÔPQRSTUÚÜÙÛVWXYZ' INTERFACE splitstr !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Splits a string. !! Splits a string and returns the portion selected by the user. MODULE PROCEDURE splitstr_i8 MODULE PROCEDURE splitstr_i16 MODULE PROCEDURE splitstr_i32 MODULE PROCEDURE splitstr_i64 END INTERFACE splitstr INTERFACE num2str !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts number into a string. !! Converts an integer or real variable into a string variable. !! Useful to open files named sequentially. MODULE PROCEDURE num2str_i8 MODULE PROCEDURE num2str_i16 MODULE PROCEDURE num2str_i32 MODULE PROCEDURE num2str_i64 MODULE PROCEDURE num2str_sp MODULE PROCEDURE num2str_dp #ifdef QPREC_FPP MODULE PROCEDURE num2str_qp #endif END INTERFACE num2str INTERFACE int2str00000 !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts an integer into a string filling with leading zeros. !! Converts an integer variable into a string variable, !! filling with leading zeros up to the limit imposed by the user. !! Useful to open files named sequentially with leading zeros in the name. MODULE PROCEDURE int2str00000_i8 MODULE PROCEDURE int2str00000_i16 MODULE PROCEDURE int2str00000_i32 MODULE PROCEDURE int2str00000_i64 END INTERFACE int2str00000 INTERFACE str2num !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string into an integer or real. !! Converts a string into an integer or real number as specified by the type of variable mold. MODULE PROCEDURE str2num_i8 MODULE PROCEDURE str2num_i16 MODULE PROCEDURE str2num_i32 MODULE PROCEDURE str2num_i64 MODULE PROCEDURE str2num_sp MODULE PROCEDURE str2num_dp #ifdef QPREC_FPP MODULE PROCEDURE str2num_qp #endif END INTERFACE str2num CONTAINS PURE FUNCTION splitstr_i8 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i8 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :), ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i8 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i8 PURE FUNCTION splitstr_i16 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i16 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i16 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i16 PURE FUNCTION splitstr_i32 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i32 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i32 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i32 PURE FUNCTION splitstr_i64 ( str , fieldNumber , delimiter , rev , mergedelim ) RESULT ( res ) CHARACTER ( LEN =* ) , INTENT ( IN ) :: str !! String that the user wants to split. INTEGER ( KIND = i64 ), INTENT ( IN ) :: fieldNumber !! Integer indicating which of the divisions to return. CHARACTER ( LEN =* ) , INTENT ( IN ), OPTIONAL :: delimiter !! String that the users wants to use as a delimiter for splitting. !! Optional parameter. Default is Space. LOGICAL , INTENT ( IN ), OPTIONAL :: rev !! If true start spliting by the end of the string. !! Optional parameter. Default is False. LOGICAL , INTENT ( IN ), OPTIONAL :: mergedelim !! If true, contiguous delimiters in the string are merged before splitting. !! Optional parameter. Default is False. CHARACTER ( LEN = :) , ALLOCATABLE :: res !! A string with the selected part of str. If the fieldNumber does not exists !! or if the delimiter does not exists it returns an empty string. !Local CHARACTER ( LEN = :), ALLOCATABLE :: d !delimiter INTEGER ( KIND = i64 ) :: i INTEGER :: pos INCLUDE 'Strings_M/include_splitstr.f90' END FUNCTION splitstr_i64 PURE FUNCTION mergeChars ( str , c ) RESULT ( res ) !! author: Emilio Castro. !! date: 14/08/2020. !! version: 1.0. !! license: MIT. !! summary: Merge characters in a string if they are contiguous. !! Merge characters in a string if they are contiguous. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to search inside for contiguous duplicated characters. CHARACTER ( LEN =* ), INTENT ( IN ) :: c !! Character to search for contiguous duplications. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String with the selected character contiguous duplications removed. CHARACTER ( LEN = :), ALLOCATABLE :: string INTEGER :: pos string = str res = '' pos = INDEX ( string , c ) DO WHILE ( pos /= 0 ) res = res // string (: pos ) string = string ( pos + 1 :) pos = INDEX ( string , c ) DO WHILE ( pos == 1 ) string = string ( 2 :) pos = INDEX ( string , c ) END DO END DO res = res // string END FUNCTION mergeChars ELEMENTAL FUNCTION startsWith ( str , substr ) RESULT ( res ) !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a string starts with a given substring. !! Checks if a string starts with a given substring. It can be an array of string. CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to check how it starts. It can be an array. CHARACTER ( LEN =* ), INTENT ( IN ) :: substr !! Substring to search to check if str starts with it. LOGICAL :: res !! True if the string starts with the substring and False otherwise. If !! substr is empty it returns True. If the input is an array, the returned !! values will also be in an array. res = INDEX ( str , substr ) == 1 END FUNCTION startsWith ELEMENTAL FUNCTION endsWith ( str , substr ) RESULT ( res ) !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a string ends with a given substring. !! Checks if a string ends with a given substring. It can be an array of string. CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String that the user wants to check how it ends. It can be an array. CHARACTER ( LEN =* ), INTENT ( IN ) :: substr !! Substring to search to check if str ends with it. LOGICAL :: res !! True if the string ends with the substring and False otherwise. If !! substr is empty it returns True. If the input is an array, the returned !! values will also be in an array. res = INDEX ( str , substr , BACK = . TRUE .) == LEN ( str ) - LEN ( substr ) + 1 END FUNCTION endsWith PURE FUNCTION num2str_i8 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i8 PURE FUNCTION num2str_i16 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i16 PURE FUNCTION num2str_i32 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i32 PURE FUNCTION num2str_i64 ( num ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number CHARACTER ( LEN = 4 ), PARAMETER :: formato = '(I0)' INCLUDE 'Strings_M/include_num2strInt.f90' END FUNCTION num2str_i64 PURE FUNCTION num2str_sp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = sp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_sp PURE FUNCTION num2str_dp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = dp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_dp #ifdef QPREC_FPP PURE FUNCTION num2str_qp ( num , formato ) RESULT ( str ) IMPLICIT NONE REAL ( KIND = qp ) , INTENT ( IN ) :: num !! Number to convert to string. CHARACTER ( LEN =* ), INTENT ( IN ) :: formato !! Format to use in the string variable. Only for real numbers. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number INTEGER :: length INCLUDE 'Strings_M/include_num2strReal.f90' END FUNCTION num2str_qp #endif PURE FUNCTION int2str00000_i8 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i8 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i8 PURE FUNCTION int2str00000_i16 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i16 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i16 PURE FUNCTION int2str00000_i32 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i32 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i32 PURE FUNCTION int2str00000_i64 ( integ , total_length ) RESULT ( str ) USE FU_Numbers , ONLY : count_digits_integer IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: integ !! Integer number to convert. This number MUST be positive. INTEGER ( KIND = i64 ), INTENT ( IN ) :: total_length !! Number of digits to use, including zeros. This number MUST be positive. CHARACTER ( LEN = :), ALLOCATABLE :: str !! String containing the number. INCLUDE 'Strings_M/include_int2str00000.f90' END FUNCTION int2str00000_i64 ELEMENTAL FUNCTION str2num_i8 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i8 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i8 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i8 ELEMENTAL FUNCTION str2num_i16 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i16 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i16 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i16 ELEMENTAL FUNCTION str2num_i32 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i32 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i32 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i32 ELEMENTAL FUNCTION str2num_i64 ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. INTEGER ( KIND = i64 ), INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. INTEGER ( KIND = i64 ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_i64 ELEMENTAL FUNCTION str2num_sp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = sp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_sp ELEMENTAL FUNCTION str2num_dp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = dp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_dp #ifdef QPREC_FPP ELEMENTAL FUNCTION str2num_qp ( str , mold ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to number. REAL ( KIND = qp ) , INTENT ( IN ) :: mold !! Real or integer value to identify the type and kind of the output. !! It is only used to set the type of the return value, so it can be any value. REAL ( KIND = qp ) :: res !! The number of the input string. INCLUDE 'Strings_M/include_str2num.f90' END FUNCTION str2num_qp #endif PURE FUNCTION replace ( str , search , repla ) RESULT ( res ) !! author: Emilio Castro. !! date: 10/07/2020. !! version: 1.0. !! license: MIT. !! summary: Searches and replaces a substring in a string !! Searches and replaces a substring in a string. It replaces !! all occurences. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to modify CHARACTER ( LEN =* ), INTENT ( IN ) :: search !! String to search in str. CHARACTER ( LEN =* ), INTENT ( IN ) :: repla !! String to replace in str. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Modified string. INTEGER :: pos INTEGER :: lensearch CHARACTER ( LEN = :), ALLOCATABLE :: straux res = '' straux = str lensearch = LEN ( search ) pos = INDEX ( straux , search ) DO WHILE ( pos /= 0 ) res = res // straux (: pos - 1 ) // repla straux = straux ( pos + lensearch :) pos = INDEX ( straux , search ) END DO res = res // straux END FUNCTION replace PURE FUNCTION strReverse ( str ) RESULT ( res ) IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str CHARACTER ( LEN = :), ALLOCATABLE :: res INTEGER :: i res = str DO i = 1 , LEN ( str ) res ( i : i ) = str ( len ( str ) - i + 1 : len ( str ) - i + 1 ) END DO END FUNCTION strReverse PURE FUNCTION upper ( str ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string to uppercase characters. !! Converts a string to uppercase characters. It works with this dataset: !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to uppercase characters. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String converted to uppercase characters. INTEGER :: i , pos res = str DO i = 1 , LEN ( res ) pos = INDEX ( lowercase , res ( i : i )) IF ( pos /= 0 ) THEN res ( i : i ) = uppercase ( pos : pos ) END IF END DO END FUNCTION upper PURE FUNCTION lower ( str ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Converts a string to lowercase characters. !! Converts a string to lowercase characters. It works with this dataset !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str !! String to convert to lowercase characters. CHARACTER ( LEN = :), ALLOCATABLE :: res !! String converted to lowercase characters. INTEGER :: i , pos res = str DO i = 1 , LEN ( res ) pos = INDEX ( uppercase , res ( i : i )) IF ( pos /= 0 ) THEN res ( i : i ) = lowercase ( pos : pos ) END IF END DO END FUNCTION lower PURE FUNCTION cistrcmp ( str1 , str2 ) RESULT ( res ) !! author: Emilio Castro. !! date: 20/08/2020. !! version: 1.0. !! license: MIT. !! summary: Case-independent string comparison. !! Case-independent string comparison. It works with this dataset: !! 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: str1 !! First string to compare. CHARACTER ( LEN =* ), INTENT ( IN ) :: str2 !! Second string to compare LOGICAL :: res !! True if both strings are equal independently of the case. False otherwise. res = upper ( str1 ) == upper ( str2 ) END FUNCTION cistrcmp END MODULE FU_Strings","tags":"","loc":"sourcefile/strings_m.f90.html"},{"title":"Timing_M.f90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Timing Source Code Timing_M.f90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Timing !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Tools to measure time spent by functions in Fortran programs. !! Tools to measure time spent by functions in Fortran programs. !! The user can use IntervalTime to get the time since the last measure or the time !! since the begining of the execution if no previous measuement is available. This point !! will be used as a starting point for the next interval. !! Use TotalTime to get the time since the beginning of the program or since the last time !! resetTotalTime is executed. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: ResetTotalTime , TotalTime , IntervalTime INTERFACE SUBROUTINE c_ResetTotalTime () BIND ( c , name = 'c_ResetTotalTime' ) USE iso_c_binding END SUBROUTINE c_ResetTotalTime FUNCTION c_TotalTime_sp () RESULT ( res ) BIND ( c , name = 'c_TotalTime_sp' ) USE iso_c_binding REAL ( KIND = C_FLOAT ) :: res END FUNCTION c_TotalTime_sp FUNCTION c_TotalTime_dp () RESULT ( res ) BIND ( c , name = 'c_TotalTime_dp' ) USE iso_c_binding REAL ( KIND = C_DOUBLE ) :: res END FUNCTION c_TotalTime_dp FUNCTION c_IntervalTime_sp () RESULT ( res ) BIND ( c , name = 'c_IntervalTime_sp' ) USE iso_c_binding REAL ( KIND = C_FLOAT ) :: res END FUNCTION c_IntervalTime_sp FUNCTION c_IntervalTime_dp () RESULT ( res ) BIND ( c , name = 'c_IntervalTime_dp' ) USE iso_c_binding REAL ( KIND = C_DOUBLE ) :: res END FUNCTION c_IntervalTime_dp END INTERFACE INTERFACE TotalTime !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Gets the time in seconds since the beginning of the program or since the last time resetTotalTime is executed. !! TotalTime gets the time in seconds (with a precision of microseconds) !! since the beginning of the program or since the last time resetTotalTime is executed. !! !! You can use mold input argument to indicate the precision of the output number. Default precision !! is the default precision of your compiler. MODULE PROCEDURE TotalTime_def MODULE PROCEDURE TotalTime_sp MODULE PROCEDURE TotalTime_dp END INTERFACE TotalTime INTERFACE IntervalTime !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Gets the time in seconds since the last measurement. !! IntervalTime gets the time in seconds (with a precision of microseconds) !! since the last measurement or the time since the begining of the execution if no previous !! measuement is available. This point will be used as a starting point for the next interval. !! !! You can use mold input argument to indicate the precision of the output number. Default precision !! is the default precision of your compiler. MODULE PROCEDURE IntervalTime_def MODULE PROCEDURE IntervalTime_sp MODULE PROCEDURE IntervalTime_dp END INTERFACE IntervalTime CONTAINS SUBROUTINE ResetTotalTime () !! author: Emilio Castro. !! date: 10/09/2020. !! version: 1.0. !! license: MIT. !! summary: Sets the starting point to count the total time. !! Sets the starting point to count the total time. IMPLICIT NONE CALL c_ResetTotalTime () END SUBROUTINE ResetTotalTime FUNCTION TotalTime_def () RESULT ( res ) IMPLICIT NONE REAL :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses default precision of the compiler used. res = REAL ( c_TotalTime_dp ()) / 1.E6 END FUNCTION TotalTime_def FUNCTION TotalTime_sp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_TotalTime_sp () / 1.E6_sp END FUNCTION TotalTime_sp FUNCTION TotalTime_dp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! Total time spent in seconds since the begining of the program or since the last !! time ResetTotalTime has been used. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_TotalTime_dp () / 1.E6_dp END FUNCTION TotalTime_dp FUNCTION IntervalTime_def () RESULT ( res ) IMPLICIT NONE REAL :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses default precision of the compiler used. res = REAL ( c_IntervalTime_dp ()) / 1.E6 END FUNCTION IntervalTime_def FUNCTION IntervalTime_sp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = sp ) :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_IntervalTime_sp () / 1.E6_sp END FUNCTION IntervalTime_sp FUNCTION IntervalTime_dp ( mold ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: mold !! Real value to identify the kind of the output. !! It is only used to set the kind of the return value, so it can be any value. REAL ( KIND = dp ) :: res !! Time spent in seconds since the last measurement or since the begining of the program !! if no previous measurement is available. Uses precision set by mold. IF (. FALSE .) res = mold !To disable compilation warning about unused variable res = c_IntervalTime_dp () / 1.E6_dp END FUNCTION IntervalTime_dp END MODULE FU_Timing","tags":"","loc":"sourcefile/timing_m.f90.html"},{"title":"Prec_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Prec Source Code Prec_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Prec !! author: Emilio Castro. !! date: 13/05/2020 !! version: 1.0. !! license: MIT. !! summary: Precision parameters to use in Fortran programs. !! Precision parameters to use in Fortran programs with real or integer variable types. USE ISO_FORTRAN_ENV IMPLICIT NONE INTEGER , PARAMETER :: sp = REAL32 !! Kind parameter to specify a real type with a storage size of 32 bits. INTEGER , PARAMETER :: dp = REAL64 !! Kind parameter to specify a real type with a storage size of 64 bits. #ifdef QPREC_FPP INTEGER , PARAMETER :: qp = REAL128 !! Kind parameter to specify a real type with a storage size of 128 bits. #endif INTEGER , PARAMETER :: i8 = INT8 !! Kind parameter to specify an integer type with a storage size of 8 bits. INTEGER , PARAMETER :: i16 = INT16 !! Kind parameter to specify an integer type with a storage size of 16 bits. INTEGER , PARAMETER :: i32 = INT32 !! Kind parameter to specify an integer type with a storage size of 32 bits. INTEGER , PARAMETER :: i64 = INT64 !! Kind parameter to specify an integer type with a storage size of 64 bits. END MODULE FU_Prec","tags":"","loc":"sourcefile/prec_m.f90.html"},{"title":"Numbers_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Numbers Source Code Numbers_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Numbers !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Functions to analyze numbers in Fortran programs. !! Functions to analyze numbers in Fortran programs. Some of these functions (is_nan and is_inf) !! are now available in the intrinsics module IEEE_ARITHMETIC and !! are provided here only for compatibility with some old programs that use them. USE FU_Prec USE , INTRINSIC :: IEEE_ARITHMETIC IMPLICIT NONE PRIVATE PUBLIC :: is_nan , is_inf , count_digits_integer PUBLIC :: eq , ne INTERFACE count_digits_integer !! author: Emilio Castro. !! date: 07/05/2020. !! version: 1.0. !! license: MIT. !! summary: Counts the number of digits of an integer. !! Counts the number of digits of an integer, including the - sign !! in case it is a negative value. MODULE PROCEDURE count_digits_integer_i8 MODULE PROCEDURE count_digits_integer_i16 MODULE PROCEDURE count_digits_integer_i32 MODULE PROCEDURE count_digits_integer_i64 END INTERFACE count_digits_integer INTERFACE is_nan !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if the value of the input variable is NaN. !! Determines if the value of the input variable is NaN. MODULE PROCEDURE is_nan_sp MODULE PROCEDURE is_nan_dp #ifdef QPREC_FPP MODULE PROCEDURE is_nan_qp #endif END INTERFACE is_nan INTERFACE is_inf !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if the value of the input variable is Infinity. !! Determines if the value of the input variable is Infinity. MODULE PROCEDURE is_inf_sp MODULE PROCEDURE is_inf_dp #ifdef QPREC_FPP MODULE PROCEDURE is_inf_qp #endif END INTERFACE is_inf INTERFACE eq !! author: Emilio Castro. !! date: 14/10/2020. !! version: 1.0. !! license: MIT. !! summary: Tests two real numbers for equality. !! Tests two real numberes for equality using a tolerance if provided by the user, !! or selecting a tolerance automatically otherwise. MODULE PROCEDURE eq_sp MODULE PROCEDURE eq_dp #ifdef QPREC_FPP MODULE PROCEDURE eq_qp #endif END INTERFACE eq INTERFACE ne !! author: Emilio Castro. !! date: 14/10/2020. !! version: 1.0. !! license: MIT. !! summary: Tests two real numbers for inequality. !! Tests two real numberes for inequality using a tolerance if provided by the user, !! or selecting a tolerance automatically otherwise. MODULE PROCEDURE ne_sp MODULE PROCEDURE ne_dp #ifdef QPREC_FPP MODULE PROCEDURE ne_qp #endif END INTERFACE ne CONTAINS PURE FUNCTION count_digits_integer_i8 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i8 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i8 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i8 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i8 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i8 PURE FUNCTION count_digits_integer_i16 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i16 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i16 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i16 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i16 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i16 PURE FUNCTION count_digits_integer_i32 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i32 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i32 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i32 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i32 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i32 PURE FUNCTION count_digits_integer_i64 ( i ) RESULT ( num_digits ) IMPLICIT NONE INTEGER ( KIND = i64 ), INTENT ( IN ) :: i !! Integer number whose digits are to be counted. INTEGER ( KIND = i64 ) :: num_digits !! The number of digits of the input number. INTEGER ( KIND = i64 ), PARAMETER :: ten = 10 , one = 1 , two = 2 INTEGER ( KIND = i64 ) :: integ INCLUDE 'Numbers_M/include_count_digits_integer.f90' END FUNCTION count_digits_integer_i64 ELEMENTAL FUNCTION is_nan_sp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_sp ELEMENTAL FUNCTION is_nan_dp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_dp #ifdef QPREC_FPP ELEMENTAL FUNCTION is_nan_qp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is NaN. False otherwise. It will !! have the same rank and dimension as the input value. res = ieee_is_nan ( val ) END FUNCTION is_nan_qp #endif ELEMENTAL FUNCTION is_inf_sp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_sp ELEMENTAL FUNCTION is_inf_dp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_dp #ifdef QPREC_FPP ELEMENTAL FUNCTION is_inf_qp ( val ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: val !! Value to analize. It can have any rank and dimension LOGICAL :: res !! True if the variable is Inf. False otherwise. It will !! have the same rank and dimension as the input value. res = . NOT . ieee_is_finite ( val ) END FUNCTION is_inf_qp #endif ELEMENTAL FUNCTION eq_sp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: x1 !! First real value to compare for equality. REAL ( KIND = sp ), INTENT ( IN ) :: x2 !! Second real value to compare for equality. REAL ( KIND = sp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if both numbers are equal according to the selected tolerance. !! False otherwise. REAL ( KIND = sp ) :: eps2 INCLUDE 'Numbers_M/include_eq.f90' END FUNCTION eq_sp ELEMENTAL FUNCTION eq_dp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: x1 !! First real value to compare for equality. REAL ( KIND = dp ), INTENT ( IN ) :: x2 !! Second real value to compare for equality. REAL ( KIND = dp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if both numbers are equal according to the selected tolerance. !! False otherwise. REAL ( KIND = dp ) :: eps2 INCLUDE 'Numbers_M/include_eq.f90' END FUNCTION eq_dp #ifdef QPREC_FPP ELEMENTAL FUNCTION eq_qp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: x1 !! First real value to compare for equality. REAL ( KIND = qp ), INTENT ( IN ) :: x2 !! Second real value to compare for equality. REAL ( KIND = qp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if both numbers are equal according to the selected tolerance. !! False otherwise. REAL ( KIND = qp ) :: eps2 INCLUDE 'Numbers_M/include_eq.f90' END FUNCTION eq_qp #endif ELEMENTAL FUNCTION ne_sp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), INTENT ( IN ) :: x1 !! First real value to compare for inequality. REAL ( KIND = sp ), INTENT ( IN ) :: x2 !! Second real value to compare for inequality. REAL ( KIND = sp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if the numbers are not equal according to the selected tolerance. !! False otherwise. REAL ( KIND = sp ) :: eps2 INCLUDE 'Numbers_M/include_ne.f90' END FUNCTION ne_sp ELEMENTAL FUNCTION ne_dp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), INTENT ( IN ) :: x1 !! First real value to compare for inequality. REAL ( KIND = dp ), INTENT ( IN ) :: x2 !! Second real value to compare for inequality. REAL ( KIND = dp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if the numbers are not equal according to the selected tolerance. !! False otherwise. REAL ( KIND = dp ) :: eps2 INCLUDE 'Numbers_M/include_ne.f90' END FUNCTION ne_dp #ifdef QPREC_FPP ELEMENTAL FUNCTION ne_qp ( x1 , x2 , eps ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), INTENT ( IN ) :: x1 !! First real value to compare for inequality. REAL ( KIND = qp ), INTENT ( IN ) :: x2 !! Second real value to compare for inequality. REAL ( KIND = qp ), OPTIONAL , INTENT ( IN ) :: eps !! User selected tolerance for the comparison. If not provided !! it will be selected automatically. LOGICAL :: res !! True if the numbers are not equal according to the selected tolerance. !! False otherwise. REAL ( KIND = qp ) :: eps2 INCLUDE 'Numbers_M/include_ne.f90' END FUNCTION ne_qp #endif END MODULE FU_Numbers","tags":"","loc":"sourcefile/numbers_m.f90.html"},{"title":"Statistics_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Statistics Source Code Statistics_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Statistics !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Statistics tools for Fortran programs. !! Statistics tools for Fortran programs. USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: mean , gmean , variance , stdev , pvariance , pstdev , & covariance , pcovariance , correlation , lin_error_propagation , median , & skewness , pskewness , linreg , logreg , expreg , potreg INTERFACE c_sort !To sort the array of values using c++ functions in order !to calculate median and quantiles. SUBROUTINE c_sort_float ( x , n ) BIND ( c , name = 'c_sort_float' ) USE iso_c_binding INTEGER ( C_INT ) , VALUE :: n REAL ( C_FLOAT ), DIMENSION ( n ), INTENT ( INOUT ) :: x END SUBROUTINE c_sort_float SUBROUTINE c_sort_double ( x , n ) BIND ( c , name = 'c_sort_double' ) USE iso_c_binding INTEGER ( C_INT ) , VALUE :: n REAL ( C_DOUBLE ), DIMENSION ( n ), INTENT ( INOUT ) :: x END SUBROUTINE c_sort_double END INTERFACE c_sort INTERFACE mean !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the mean value. !! Calculates the mean value of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\overline{x} = \\frac{\\sum\\limits_{i=1}&#94;n x_{i}}{n} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = mean(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the mean value of ```x```. MODULE PROCEDURE mean_sp MODULE PROCEDURE mean_dp #ifdef QPREC_FPP MODULE PROCEDURE mean_qp #endif END INTERFACE mean INTERFACE gmean !! author: Emilio Castro. !! date: 27/05/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the geometric mean. !! Calculates the geometric mean of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\overline{x} = \\left(\\prod\\limits_{i=1}&#94;{n}x_{i}\\right)&#94;\\frac{1}{n} !! = \\sqrt[n]{x_{1} \\times x_{2} \\times \\dots \\times x_{n}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = gmean(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the geometric mean of ```x```. MODULE PROCEDURE gmean_sp MODULE PROCEDURE gmean_dp #ifdef QPREC_FPP MODULE PROCEDURE gmean_qp #endif END INTERFACE gmean INTERFACE variance !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample variance. !! Calculates the sample variance of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma&#94;{2} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n-1} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = variance(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample variance of ```x```. MODULE PROCEDURE variance_sp MODULE PROCEDURE variance_dp #ifdef QPREC_FPP MODULE PROCEDURE variance_qp #endif END INTERFACE variance INTERFACE stdev !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample standard deviation. !! Calculates the sample standard deviation of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n-1}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = stdev(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample standard deviation of ```x```. MODULE PROCEDURE stdev_sp MODULE PROCEDURE stdev_dp #ifdef QPREC_FPP MODULE PROCEDURE stdev_qp #endif END INTERFACE stdev INTERFACE pvariance !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population variance. !! Calculates the population variance of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma&#94;{2} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pvariance(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population variance of ```x```. MODULE PROCEDURE pvariance_sp MODULE PROCEDURE pvariance_dp #ifdef QPREC_FPP MODULE PROCEDURE pvariance_qp #endif END INTERFACE pvariance INTERFACE pstdev !! author: Emilio Castro. !! date: 09/06/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population standard deviation. !! Calculates the population standard deviation of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! \\sigma = \\sqrt{\\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)&#94;2}{n}} !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pstdev(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population standard deviation of ```x```. MODULE PROCEDURE pstdev_sp MODULE PROCEDURE pstdev_dp #ifdef QPREC_FPP MODULE PROCEDURE pstdev_qp #endif END INTERFACE pstdev INTERFACE covariance !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample covariance between two variables. !! Calculates the sample covariance between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\sigma_{xy} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)\\left(y_{i} - !!              \\overline{y}\\right)}{n-1} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = covariance(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the sample covariance of ```x``` and ```y```. MODULE PROCEDURE covariance_sp MODULE PROCEDURE covariance_dp #ifdef QPREC_FPP MODULE PROCEDURE covariance_qp #endif END INTERFACE covariance INTERFACE pcovariance !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population covariance between two variables. !! Calculates the population covariance between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\sigma_{xy} = \\frac{\\sum\\limits_{i=1}&#94;{n}\\left(x_{i} - !!              \\overline{x}\\right)\\left(y_{i} - !!              \\overline{y}\\right)}{n} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = pcovariance(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the population covariance of ```x``` and ```y```. MODULE PROCEDURE pcovariance_sp MODULE PROCEDURE pcovariance_dp #ifdef QPREC_FPP MODULE PROCEDURE pcovariance_qp #endif END INTERFACE pcovariance INTERFACE correlation !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the correlation coefficient between two variables. !! Calculates the correlation coefficient between two variables given in two vectors !! of any size with one dimension applying the following equation: !! !! \\rho_{xy} = \\frac{\\sigma_{xy} !!                 }{\\sigma_{x} \\sigma_{y}} !! !! where: !! !! * x and y are vectors with real numbers. !! * n is how many numbers are included in x and y. !! !! Usage: !! !! ``` !! z = correlation(x,y) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```z``` = real number of the same kind as ```x``` and ```y``` with the correlation coefficient of ```x``` and ```y```. MODULE PROCEDURE correlation_sp MODULE PROCEDURE correlation_dp #ifdef QPREC_FPP MODULE PROCEDURE correlation_qp #endif END INTERFACE correlation INTERFACE lin_error_propagation !! author: Emilio Castro. !! date: 10/08/2020. !! version: 1.0. !! license: MIT. !! summary: Performs linear error (or uncertainties) propagation. !! Performs linear error (or uncertainties) propagation given the !! sensitivity coefficients and a covariance matrix. The following !! formula is applied: !! !! \\sigma&#94;2_{y} = S \\Sigma&#94;{X} S&#94;\\intercal !! where: !! !! * y is the response whose uncertainty is to be calculated. !! * X is a set of input parameters to propagate their uncertainty to y. !! * S is the vector of sensitivity coefficients of y with respect to the !!   different parameters in X. !! * \\Sigma&#94;{x} is the covariance matrix of the parameters in X. !! !! Usage: !! !! ``` !! y = lin_error_propagation(s,m) !! ``` !! !! where: !! !! * ```s``` = vector of rank 1 with real numbers containing the sensitivity coefficients. !! * ```m``` = array of rank 2 containing the covariance matrix. !! * ```y``` = real number of the same kind as ```s``` and ```m``` with the !! error or uncertainty propagated to this new variable. MODULE PROCEDURE lin_error_propagation_sp MODULE PROCEDURE lin_error_propagation_dp #ifdef QPREC_FPP MODULE PROCEDURE lin_error_propagation_qp #endif END INTERFACE lin_error_propagation INTERFACE median !! author: Emilio Castro. !! date: 12/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the median value. !! Calculates the median value. !! This function does not work with quadruple precision numbers !! because of the ordering subroutine written in C++. !! !! Usage: !! !! ``` !! y = median(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the median of ```x```. MODULE PROCEDURE median_sp MODULE PROCEDURE median_dp END INTERFACE median INTERFACE skewness !! author: Emilio Castro. !! date: 19/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the sample skewness of a set of values. !! Calculates the sample skewness of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! S_{x} = \\frac{n}{\\left( n-1 \\right)\\left( n-2 \\right) !!               }\\sum\\limits_{i=1}&#94;{n}\\left( \\frac{x_{i}-\\overline{x} !!               }{\\sigma_{x}} \\right)&#94;3 !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = skewness(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the sample skewness of ```x```. MODULE PROCEDURE skewness_sp MODULE PROCEDURE skewness_dp #ifdef QPREC_FPP MODULE PROCEDURE skewness_qp #endif END INTERFACE skewness INTERFACE pskewness !! author: Emilio Castro. !! date: 19/08/2020. !! version: 1.0. !! license: MIT. !! summary: Calculates the population skewness of a set of values. !! Calculates the population skewness of a set of values given in a vector !! of any size with one dimension applying the following equation: !! !! S_{x} = \\frac{1}{n !!               }\\sum\\limits_{i=1}&#94;{n}\\left( \\frac{x_{i}-\\overline{x} !!               }{\\sigma_{x}} \\right)&#94;3 !! !! where: !! !! * x is a vector with real numbers. !! * n is how many numbers are included in x. !! !! Usage: !! !! ``` !! y = pskewness(x) !! ``` !! !! where: !! !! * ```x``` = vector of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```y``` = real number of the same kind as ```x``` with the population skewness of ```x```. MODULE PROCEDURE pskewness_sp MODULE PROCEDURE pskewness_dp #ifdef QPREC_FPP MODULE PROCEDURE pskewness_qp #endif END INTERFACE pskewness INTERFACE regression !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs different types of regression between two sets of values. !! Performs different types of regression between two sets of values. This is a !! private subroutine accesible by using one of [[linreg]], [[logreg]], [[expreg]] or [[potreg]]. MODULE PROCEDURE regression_sp MODULE PROCEDURE regression_dp #ifdef QPREC_FPP MODULE PROCEDURE regression_qp #endif END INTERFACE regression INTEGER , PARAMETER :: linreg_id = 1 !! Selector flag for linear regression in function [[regression]]. INTEGER , PARAMETER :: logreg_id = 2 !! Selector flag for logarithmic regression in function [[regression]]. INTEGER , PARAMETER :: expreg_id = 3 !! Selector flag for exponential regression in function [[regression]]. INTEGER , PARAMETER :: potreg_id = 4 !! Selector flag for potential regression in function [[regression]]. INTERFACE linreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs linear regression between two sets of values. !! Performs linear regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = a \\cdot x+b !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to measure the goodness of fit. !! !! Usage: !! !! ``` !! CALL linreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE linreg_sp MODULE PROCEDURE linreg_dp #ifdef QPREC_FPP MODULE PROCEDURE linreg_qp #endif END INTERFACE linreg INTERFACE logreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs logarithmic regression between two sets of values. !! Performs logarithmic regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = a \\cdot ln(x)+b !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL logreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE logreg_sp MODULE PROCEDURE logreg_dp #ifdef QPREC_FPP MODULE PROCEDURE logreg_qp #endif END INTERFACE logreg INTERFACE expreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs exponential regression between two sets of values. !! Performs exponential regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = b \\cdot e&#94;{(a \\cdot x)} !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL expreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE expreg_sp MODULE PROCEDURE expreg_dp #ifdef QPREC_FPP MODULE PROCEDURE expreg_qp #endif END INTERFACE expreg INTERFACE potreg !! author: Emilio Castro. !! date: 23/09/2020. !! version: 1.0. !! license: MIT. !! summary: Performs potential regression between two sets of values. !! Performs potential regression between two sets of values, !! obtaining parameters a and b of the following equation. !! !! y = b \\cdot x&#94;a !! !! where: !! !! * x and y are vectors with real numbers. !! * a and b are the regression coefficients. !! !! Parameter R&#94;2 is also calculated to determine the goodness of fit. !! !! Usage: !! !! ``` !! CALL potreg(x,y,a,b,R2) !! ``` !! !! where: !! !! * ```x``` and ```y``` = vectors of rank 1 with real numbers. See examples to use an array of !! rank larger than 1. !! * ```a```, ```b``` = regression coefficients calculated by the subroutine. !! * ```R2``` = the determination coefficient to measure the goodness of fit, calculated by the subroutine. MODULE PROCEDURE potreg_sp MODULE PROCEDURE potreg_dp #ifdef QPREC_FPP MODULE PROCEDURE potreg_qp #endif END INTERFACE potreg CONTAINS PURE FUNCTION mean_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_sp PURE FUNCTION mean_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_dp #ifdef QPREC_FPP PURE FUNCTION mean_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the mean value. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the average of x. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_mean.f90' END FUNCTION mean_qp #endif PURE FUNCTION gmean_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_sp PURE FUNCTION gmean_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_dp #ifdef QPREC_FPP PURE FUNCTION gmean_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the geometric mean. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the geometric mean of the x. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_gmean.f90' END FUNCTION gmean_qp #endif PURE FUNCTION variance_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = sp REAL ( KIND = sp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_sp PURE FUNCTION variance_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = dp REAL ( KIND = dp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_dp #ifdef QPREC_FPP PURE FUNCTION variance_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample variance. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample variance of x. INTEGER , PARAMETER :: prec = qp REAL ( KIND = qp ) :: avg INCLUDE 'Statistics_M/include_variance.f90' END FUNCTION variance_qp #endif PURE FUNCTION stdev_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_sp PURE FUNCTION stdev_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_dp #ifdef QPREC_FPP PURE FUNCTION stdev_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample standard deviation of x. res = SQRT ( variance ( x )) END FUNCTION stdev_qp #endif PURE FUNCTION pvariance_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = sp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_sp PURE FUNCTION pvariance_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = dp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_dp #ifdef QPREC_FPP PURE FUNCTION pvariance_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population variance. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the variance of x. INTEGER , PARAMETER :: prec = qp res = variance ( x ) * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pvariance_qp #endif PURE FUNCTION pstdev_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_sp PURE FUNCTION pstdev_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_dp #ifdef QPREC_FPP PURE FUNCTION pstdev_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population standard deviation. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population standard deviation of x. res = SQRT ( pvariance ( x )) END FUNCTION pstdev_qp #endif PURE FUNCTION covariance_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = sp REAL ( KIND = sp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_sp PURE FUNCTION covariance_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = dp REAL ( KIND = dp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_dp #ifdef QPREC_FPP PURE FUNCTION covariance_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample covariance between both variables. INTEGER , PARAMETER :: prec = qp REAL ( KIND = qp ) :: avg1 , avg2 INCLUDE 'Statistics_M/include_covariance.f90' END FUNCTION covariance_qp #endif PURE FUNCTION pcovariance_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = sp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_sp PURE FUNCTION pcovariance_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = dp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_dp #ifdef QPREC_FPP PURE FUNCTION pcovariance_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = qp res = covariance ( x , y ) & * REAL ( SIZE ( x ) - 1 , prec ) / REAL ( SIZE ( x ), prec ) END FUNCTION pcovariance_qp #endif PURE FUNCTION correlation_sp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_sp PURE FUNCTION correlation_dp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_dp #ifdef QPREC_FPP PURE FUNCTION correlation_qp ( x , y ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population covariance between both variables. INTEGER , PARAMETER :: prec = qp INCLUDE 'Statistics_M/include_correlation.f90' END FUNCTION correlation_qp #endif PURE FUNCTION lin_error_propagation_sp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = sp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_sp PURE FUNCTION lin_error_propagation_dp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = dp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_dp #ifdef QPREC_FPP PURE FUNCTION lin_error_propagation_qp ( sensitivities , matcovar ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: sensitivities !! Vector of sensitivity coefficients of the new variable with the respect the prior variable. !! It can have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:,:), INTENT ( IN ) :: matcovar !! Covariance matrix with the error or uncertainty of the prior variable. !! Dimensions of sensitivities and matcovar must be in agreement. REAL ( KIND = qp ) :: res !! Real number with the error or uncertainty (variance) propagated to the new variable. INCLUDE 'Statistics_M/include_lin_error_propagation.f90' END FUNCTION lin_error_propagation_qp #endif FUNCTION median_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the median. It can !! have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the median REAL ( KIND = sp ), DIMENSION ( SIZE ( x )) :: x_cp ! x_cp is a copy of x to avoid modifying it when ordering INTEGER :: size_x INTEGER , PARAMETER :: prec = sp INCLUDE 'Statistics_M/include_median.f90' END FUNCTION median_sp FUNCTION median_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the median. It can !! have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the median REAL ( KIND = dp ), DIMENSION ( SIZE ( x )) :: x_cp ! x_cp is a copy of x to avoid modifying it when ordering INTEGER :: size_x INTEGER , PARAMETER :: prec = dp INCLUDE 'Statistics_M/include_median.f90' END FUNCTION median_dp PURE FUNCTION skewness_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = sp ) :: avg ! mean value REAL ( KIND = sp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_sp PURE FUNCTION skewness_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = dp ) :: avg ! mean value REAL ( KIND = dp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_dp #ifdef QPREC_FPP PURE FUNCTION skewness_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the sample skewness. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the sample skewness of the x. REAL ( KIND = qp ) :: avg ! mean value REAL ( KIND = qp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_skewness.f90' END FUNCTION skewness_qp #endif PURE FUNCTION pskewness_sp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = sp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = sp ) :: avg ! mean value REAL ( KIND = sp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_sp PURE FUNCTION pskewness_dp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = dp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = dp ) :: avg ! mean value REAL ( KIND = dp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_dp #ifdef QPREC_FPP PURE FUNCTION pskewness_qp ( x ) RESULT ( res ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers to calculate the population skewness. !! It can have any size and it must have one dimension. REAL ( KIND = qp ) :: res !! Real number with the population skewness of the x. REAL ( KIND = qp ) :: avg ! mean value REAL ( KIND = qp ) :: sd ! standard deviation INTEGER :: n INCLUDE 'Statistics_M/include_pskewness.f90' END FUNCTION pskewness_qp #endif PURE SUBROUTINE linreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_sp PURE SUBROUTINE linreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_dp #ifdef QPREC_FPP PURE SUBROUTINE linreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( linreg_id , x , y , a , b , R2 ) END SUBROUTINE linreg_qp #endif PURE SUBROUTINE logreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_sp PURE SUBROUTINE logreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_dp #ifdef QPREC_FPP PURE SUBROUTINE logreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( logreg_id , x , y , a , b , R2 ) END SUBROUTINE logreg_qp #endif PURE SUBROUTINE expreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_sp PURE SUBROUTINE expreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_dp #ifdef QPREC_FPP PURE SUBROUTINE expreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( expreg_id , x , y , a , b , R2 ) END SUBROUTINE expreg_qp #endif PURE SUBROUTINE potreg_sp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_sp PURE SUBROUTINE potreg_dp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_dp #ifdef QPREC_FPP PURE SUBROUTINE potreg_qp ( x , y , a , b , R2 ) IMPLICIT NONE REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. CALL regression ( potreg_id , x , y , a , b , R2 ) END SUBROUTINE potreg_qp #endif PURE SUBROUTINE regression_sp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = sp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = sp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = sp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = sp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = sp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_sp PURE SUBROUTINE regression_dp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = dp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = dp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = dp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = dp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = dp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_dp #ifdef QPREC_FPP PURE SUBROUTINE regression_qp ( typeRegression , x , y , a , b , R2 ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: typeRegression !! Flag to select the type of regression. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: x !! Vector of real numbers with the values of the first variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), DIMENSION (:), INTENT ( IN ) :: y !! Vector of real numbers with the values of the second variable. It can !! have any size and it must have one dimension. REAL ( KIND = qp ), INTENT ( OUT ) :: a !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: b !! Regression coefficient. REAL ( KIND = qp ), INTENT ( OUT ) :: R2 !! Determination coefficient. REAL ( KIND = qp ), DIMENSION ( SIZE ( x )) :: x_cp REAL ( KIND = qp ), DIMENSION ( SIZE ( y )) :: y_cp REAL ( KIND = qp ) :: var_x , var_y , covar_xy INCLUDE 'Statistics_M/include_regression.f90' END SUBROUTINE regression_qp #endif END MODULE FU_Statistics","tags":"","loc":"sourcefile/statistics_m.f90.html"},{"title":"Files_M.F90 – ecasglez's FortranUtilities","text":"Contents Modules FU_Files Source Code Files_M.F90 Source Code !-------------------------------------------------------------------- ! FortranUtilities !-------------------------------------------------------------------- MODULE FU_Files !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Useful tools to manipulate files in Fortran programs. !! Useful tools to manipulate files in Fortran programs. USE iso_c_binding USE FU_Prec IMPLICIT NONE PRIVATE PUBLIC :: mkdir , cp , mv , rm , exists , is_directory , is_empty , is_regular_file #ifdef LIN_CPP PUBLIC :: is_symlink , create_symlink #endif PUBLIC :: filesep , is_path_absolute , is_path_relative , extension , stem , filename , & parent_path , readMatrix , writeMatrix , replace_extension , replace_filename , & remove_filename #ifdef WIN_CPP CHARACTER , PARAMETER :: filesep = ACHAR ( 92 ) !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #elif LIN_CPP CHARACTER , PARAMETER :: filesep = '/' !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #else CHARACTER , PARAMETER :: filesep = '/' !! Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. #endif INTERFACE FUNCTION c_createdir ( dir , ign ) RESULT ( res ) BIND ( c , name = 'c_createdir' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: dir LOGICAL ( C_BOOL ), INTENT ( IN ) :: ign LOGICAL ( C_BOOL ) :: res END FUNCTION c_createdir #ifdef LIN_CPP FUNCTION c_create_symlink ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_create_symlink' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_create_symlink #endif FUNCTION c_copy_file ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_copy_file' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_copy_file FUNCTION c_move_file ( src , dest , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_move_file' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: src , dest LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_move_file FUNCTION c_remove ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_remove' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_remove FUNCTION c_exists ( fname ) RESULT ( res ) BIND ( c , name = 'c_exists' ) USE iso_c_binding IMPLICIT NONE CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) :: res END FUNCTION c_exists FUNCTION c_is_directory ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_directory' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_directory FUNCTION c_is_empty ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_empty' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_empty FUNCTION c_is_regular_file ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_regular_file' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_regular_file #ifdef LIN_CPP FUNCTION c_is_symlink ( fname , ignoreErrors ) RESULT ( res ) BIND ( c , name = 'c_is_symlink' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) , VALUE :: ignoreErrors LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_symlink #endif FUNCTION c_is_absolute ( fname ) RESULT ( res ) BIND ( c , name = 'c_is_absolute' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ), INTENT ( IN ) :: fname LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_absolute FUNCTION c_is_relative ( fname ) RESULT ( res ) BIND ( c , name = 'c_is_relative' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname LOGICAL ( C_BOOL ) :: res END FUNCTION c_is_relative SUBROUTINE c_extension ( fname ) BIND ( c , name = 'c_extension' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname END SUBROUTINE c_extension SUBROUTINE c_replace_extension ( fname , ext ) BIND ( c , name = 'c_replace_extension' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname CHARACTER ( C_CHAR ), DIMENSION ( * ) :: ext END SUBROUTINE c_replace_extension SUBROUTINE c_stem ( fname ) BIND ( c , name = 'c_stem' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname END SUBROUTINE c_stem SUBROUTINE c_filename ( fname ) BIND ( c , name = 'c_filename' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname END SUBROUTINE c_filename SUBROUTINE c_replace_filename ( fname , newname ) BIND ( c , name = 'c_replace_filename' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname CHARACTER ( C_CHAR ), DIMENSION ( * ) :: newname END SUBROUTINE c_replace_filename SUBROUTINE c_remove_filename ( fname ) BIND ( c , name = 'c_remove_filename' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname END SUBROUTINE c_remove_filename SUBROUTINE c_parent_path ( fname ) BIND ( c , name = 'c_parent_path' ) USE iso_c_binding CHARACTER ( C_CHAR ), DIMENSION ( * ) :: fname END SUBROUTINE c_parent_path END INTERFACE INTERFACE readMatrix !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. The return variable must have ALLOCATABLE attribute, !! and must not be allocated (the subroutine takes care of allocation but not about deallocation). MODULE PROCEDURE readMatrix_i8 MODULE PROCEDURE readMatrix_i16 MODULE PROCEDURE readMatrix_i32 MODULE PROCEDURE readMatrix_i64 MODULE PROCEDURE readMatrix_sp MODULE PROCEDURE readMatrix_dp #ifdef QPREC_FPP MODULE PROCEDURE readMatrix_qp #endif END INTERFACE readMatrix INTERFACE writeMatrix !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. MODULE PROCEDURE writeMatrix_i8 MODULE PROCEDURE writeMatrix_i16 MODULE PROCEDURE writeMatrix_i32 MODULE PROCEDURE writeMatrix_i64 MODULE PROCEDURE writeMatrix_sp MODULE PROCEDURE writeMatrix_dp #ifdef QPREC_FPP MODULE PROCEDURE writeMatrix_qp #endif END INTERFACE writeMatrix CONTAINS FUNCTION mkdir ( dir , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Creates a directory. !! Creates a directory. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: dir !! Path and name of the directory to be created. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_createdir ( dir // C_NULL_CHAR , ign ) END FUNCTION mkdir #ifdef LIN_CPP FUNCTION create_symlink ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Creates a symlink to a file or directory (Linux only). !! Creates a symlink to a file or directory (Linux only). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file or directory to be linked. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination link. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_create_symlink ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION create_symlink #endif FUNCTION cp ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Copies a file or directory. !! Copies a file or directory. Directories are copied recursively. !! Existing files are overwritten. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file to be copied. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination file. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_copy_file ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION cp FUNCTION mv ( src , dest , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Moves or renames a file or directory. !! Moves or renames a file or directory. When moving a directory if the !! destination is an already existing directory which is not empty an error is shown !! and nothing is done. The destination folder must be removed first using function rm. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: src !! Name of the file to be moved. CHARACTER ( LEN =* ), INTENT ( IN ) :: dest !! Name of the destination file. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_move_file ( src // C_NULL_CHAR , dest // C_NULL_CHAR , ign ) END FUNCTION mv FUNCTION rm ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Removes a file or directory. !! Removes a file or directory. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file or directory to be removed. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if the process has been succesful. False in case of error. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_remove ( fname // C_NULL_CHAR , ign ) END FUNCTION rm FUNCTION exists ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a file or directory exists. !! Checks if a file or directory exists. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be check for existence. LOGICAL :: res !! True if the file exists. False otherwise. res = c_exists ( fname // C_NULL_CHAR ) END FUNCTION exists FUNCTION is_directory ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a directory exists. !! Checks if a directory exists. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the directory to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a directory. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_directory ( fname // C_NULL_CHAR , ign ) END FUNCTION is_directory FUNCTION is_empty ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a file is empty. !! Checks if a file is empty. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is an empty file. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_empty ( fname // C_NULL_CHAR , ign ) END FUNCTION is_empty FUNCTION is_regular_file ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a regular file exists: it is not a directory, symlink, etc. !! Checks if a regular file exists: it is not a directory, symlink, etc. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the file to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a regular file. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_regular_file ( fname // C_NULL_CHAR , ign ) END FUNCTION is_regular_file #ifdef LIN_CPP FUNCTION is_symlink ( fname , ignoreErrors ) RESULT ( res ) !! author: Emilio Castro. !! date: 16/06/2020. !! version: 1.0. !! license: MIT. !! summary: Checks if a symlink exists (Linux only). !! Checks if a symlink exists (Linux only). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Name of the symlink to be checked. LOGICAL , OPTIONAL , INTENT ( IN ) :: ignoreErrors !! True to print a detailed description of the error message. !! Optional parameter. Default is False. LOGICAL :: res !! True if fname is a symlink. False otherwise. LOGICAL ( C_BOOL ) :: ign IF ( PRESENT ( ignoreErrors )) THEN ign = LOGICAL ( ignoreErrors , KIND = C_BOOL ) ELSE ign = . FALSE . END IF res = c_is_symlink ( fname // C_NULL_CHAR , ign ) END FUNCTION is_symlink #endif FUNCTION is_path_absolute ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if a path is absolute or not !! Determines if a path is absolute or not. Returns True if path is absolute !! and False if path is relative. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Path to a file. LOGICAL :: res !! True if the path is absolute and false if the path is relative. res = c_is_absolute ( fname // C_NULL_CHAR ) END FUNCTION is_path_absolute FUNCTION is_path_relative ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines if a path is relative or not !! Determines if a path is relative or not. Returns True if path is relative !! and False if path is absolute. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Path to a file. LOGICAL :: res !! True if the path is relative and false if the path is absolute. res = c_is_relative ( fname // C_NULL_CHAR ) END FUNCTION is_path_relative FUNCTION extension ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 27/07/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the extension of a file. !! Determines the extension of a file given its name or path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Extension of the file including the \"dot\". Empty path is returned if no extension is found. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_extension ( c_string ) res = c_to_f ( c_string ) END FUNCTION extension FUNCTION replace_extension ( fname , ext ) RESULT ( res ) !! author: Emilio Castro. !! date: 21/01/2021. !! version: 1.0. !! license: MIT. !! summary: Changes the extension of a filename. !! Changes the extension of a filename. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN =* ), INTENT ( IN ) :: ext !! New extension for the fname. CHARACTER ( LEN = :), ALLOCATABLE :: res !! The fname value with the modified extension. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string , c_string1 c_string = fname // C_NULL_CHAR c_string1 = ext // C_NULL_CHAR CALL c_replace_extension ( c_string , c_string1 ) res = c_to_f ( c_string ) END FUNCTION replace_extension FUNCTION stem ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the filename without the final extension given a path. !! Determines the filename without the final extension given a path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Filename without the final extension. If filename consists of an extension only, the !! extension is returned. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_stem ( c_string ) res = c_to_f ( c_string ) END FUNCTION stem FUNCTION filename ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the full filename given a path. !! Determines the full filename given a path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Full filename given in the path. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_filename ( c_string ) res = c_to_f ( c_string ) END FUNCTION filename FUNCTION replace_filename ( fname , newname ) RESULT ( res ) !! author: Emilio Castro. !! date: 21/01/2021. !! version: 1.0. !! license: MIT. !! summary: Changes the filename of a path. !! Changes the filename of a path. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN =* ), INTENT ( IN ) :: newname !! New filename for the fname. CHARACTER ( LEN = :), ALLOCATABLE :: res !! The fname value with the modified filename. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string , c_string1 c_string = fname // C_NULL_CHAR c_string1 = newname // C_NULL_CHAR CALL c_replace_filename ( c_string , c_string1 ) res = c_to_f ( c_string ) END FUNCTION replace_filename FUNCTION remove_filename ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 21/01/2021. !! version: 1.0. !! license: MIT. !! summary: Removes the filename from a path. !! Removes the filename from a path. It is similar to function !! [[parent_path]] but this one does not remove railing path separators (if any). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! The fname value with the filename removed. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_remove_filename ( c_string ) res = c_to_f ( c_string ) END FUNCTION remove_filename FUNCTION parent_path ( fname ) RESULT ( res ) !! author: Emilio Castro. !! date: 06/08/2020. !! version: 1.0. !! license: MIT. !! summary: Determines the path to the parent directory given the path to a file. !! Determines the path to the parent directory given the path to a file. It is similar !! to function [[remove_filename]] but this one removes trailing path separators (if any). IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: fname !! Filename or path to a file. CHARACTER ( LEN = :), ALLOCATABLE :: res !! Path of the parent directory without final slash. CHARACTER ( LEN = :, KIND = C_CHAR ), ALLOCATABLE :: c_string c_string = fname // C_NULL_CHAR CALL c_parent_path ( c_string ) res = c_to_f ( c_string ) END FUNCTION parent_path SUBROUTINE readMatrix_i8 ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. INTEGER ( KIND = i8 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_i8 SUBROUTINE readMatrix_i16 ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. INTEGER ( KIND = i16 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_i16 SUBROUTINE readMatrix_i32 ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. INTEGER ( KIND = i32 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_i32 SUBROUTINE readMatrix_i64 ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. INTEGER ( KIND = i64 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_i64 SUBROUTINE readMatrix_sp ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. REAL ( KIND = sp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_sp SUBROUTINE readMatrix_dp ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_dp #ifdef QPREC_FPP SUBROUTINE readMatrix_qp ( filename , res ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Reads a matrix from a file. !! Reads a matrix from a file. The file must have the proper format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns must be separated using blanks. !! !! The file is then opened, read and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to read the matrix from. REAL ( KIND = qp ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: res !! Values read from the matrix. This output variable must be allocatable but !! must not be allocated prior to call readMatrix as it is allocated here. However !! deallocation must be done manually by the user when finishes using the information. INTEGER :: nrows , ncols , r , c , u LOGICAL :: header ! True if there is a line with a header to skip. INCLUDE 'Files_M/include_readMatrix.f90' END SUBROUTINE readMatrix_qp #endif SUBROUTINE writeMatrix_i8 ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. INTEGER ( KIND = i8 ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: I3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_i8 SUBROUTINE writeMatrix_i16 ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. INTEGER ( KIND = i16 ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: I3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_i16 SUBROUTINE writeMatrix_i32 ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. INTEGER ( KIND = i32 ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: I3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_i32 SUBROUTINE writeMatrix_i64 ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. INTEGER ( KIND = i64 ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: I3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_i64 SUBROUTINE writeMatrix_sp ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. REAL ( KIND = sp ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: F8.3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_sp SUBROUTINE writeMatrix_dp ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. REAL ( KIND = dp ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: F8.3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_dp #ifdef QPREC_FPP SUBROUTINE writeMatrix_qp ( filename , matrix , header , formato ) !! author: Emilio Castro. !! date: 01/12/2020. !! version: 1.0. !! license: MIT. !! summary: Writes a matrix to a file. !! Writes a matrix to a file. The file will have the following format: !! !! First line includes the number of rows, the number of columns and a logical !! indicating if the second line is a header line to be skipped. Example: 5 9 T. !! !! The second row can be a header or not. !! !! Then the matrix comes. The different columns are separated using blanks. !! !! The file is then opened, written and closed. IMPLICIT NONE CHARACTER ( LEN =* ), INTENT ( IN ) :: filename !! Filename of the file to write the matrix to. REAL ( KIND = qp ), DIMENSION (:,:), INTENT ( IN ) :: matrix !! Values of the matrix to write to the file. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: header !! Header to be writen in the second line. CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: formato !! Format to use for the numbers without parenthesis. Example: F8.3 INTEGER :: nrows , ncols , r , c , u INCLUDE 'Files_M/include_writeMatrix.f90' END SUBROUTINE writeMatrix_qp #endif ! Auxiliary functions FUNCTION c_to_f ( c_string ) RESULT ( res ) ! Auxiliary function used as interface to convert c strings to fortran strings IMPLICIT NONE CHARACTER ( C_CHAR ) :: c_string CHARACTER ( LEN = :), ALLOCATABLE :: res INTEGER :: l !length l = 1 DO WHILE ( c_string ( l : l ) /= C_NULL_CHAR ) l = l + 1 END DO res = c_string ( 1 : l - 1 ) END FUNCTION c_to_f END MODULE FU_Files","tags":"","loc":"sourcefile/files_m.f90.html"},{"title":"include_covariance.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_covariance.f90 Source Code avg1 = mean ( x ) avg2 = mean ( y ) res = SUM (( x (:) - avg1 ) * ( y (:) - avg2 )) res = res / REAL ( SIZE ( x ) - 1 , prec )","tags":"","loc":"sourcefile/include_covariance.f90.html"},{"title":"include_lin_error_propagation.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_lin_error_propagation.f90 Source Code res = DOT_PRODUCT ( MATMUL ( sensitivities , matcovar ), sensitivities )","tags":"","loc":"sourcefile/include_lin_error_propagation.f90.html"},{"title":"include_gmean.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_gmean.f90 Source Code res = PRODUCT ( x ) ** ( 1._prec / REAL ( SIZE ( x ), prec ))","tags":"","loc":"sourcefile/include_gmean.f90.html"},{"title":"include_pskewness.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_pskewness.f90 Source Code avg = mean ( x ) sd = pstdev ( x ) n = SIZE ( x ) res = SUM (( x (:) - avg ) ** 3 ) / sd ** 3 / n","tags":"","loc":"sourcefile/include_pskewness.f90.html"},{"title":"include_skewness.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_skewness.f90 Source Code avg = mean ( x ) sd = stdev ( x ) n = SIZE ( x ) res = SUM (( x (:) - avg ) ** 3 ) / sd ** 3 * n / ( n - 1 ) / ( n - 2 )","tags":"","loc":"sourcefile/include_skewness.f90.html"},{"title":"include_correlation.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_correlation.f90 Source Code res = covariance ( x , y ) / stdev ( x ) / stdev ( y )","tags":"","loc":"sourcefile/include_correlation.f90.html"},{"title":"include_regression.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_regression.f90 Source Code SELECT CASE ( typeRegression ) CASE ( linreg_id ) x_cp = x y_cp = y CASE ( logreg_id ) x_cp = LOG ( x ) y_cp = y CASE ( expreg_id ) x_cp = x y_cp = LOG ( y ) CASE ( potreg_id ) x_cp = LOG10 ( x ) y_cp = LOG10 ( y ) END SELECT var_x = variance ( x_cp ) var_y = variance ( y_cp ) covar_xy = covariance ( x_cp , y_cp ) a = covar_xy / var_x SELECT CASE ( typeRegression ) CASE ( expreg_id ) b = EXP ( mean ( y_cp ) - a * mean ( x_cp )) CASE ( potreg_id ) b = 10 ** ( mean ( y_cp ) - a * mean ( x_cp )) CASE DEFAULT b = mean ( y_cp ) - a * mean ( x_cp ) END SELECT R2 = covar_xy ** 2 / var_x / var_y","tags":"","loc":"sourcefile/include_regression.f90.html"},{"title":"include_mean.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_mean.f90 Source Code res = SUM ( x ) / REAL ( SIZE ( x ), prec )","tags":"","loc":"sourcefile/include_mean.f90.html"},{"title":"include_variance.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_variance.f90 Source Code avg = mean ( x ) res = SUM (( x (:) - avg ) ** 2 ) res = res / REAL ( SIZE ( x ) - 1 , prec )","tags":"","loc":"sourcefile/include_variance.f90.html"},{"title":"include_num2strInt.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_num2strInt.f90 Source Code ALLOCATE ( character ( len = count_digits_integer ( num )) :: str ) WRITE ( str , formato ) num","tags":"","loc":"sourcefile/include_num2strint.f90.html"},{"title":"include_str2num.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_str2num.f90 Source Code IF (. FALSE .) res = mold !To disable compilation warning about unused variable READ ( str , * ) res","tags":"","loc":"sourcefile/include_str2num.f90.html"},{"title":"include_splitstr.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_splitstr.f90 Source Code IF ( PRESENT ( delimiter )) THEN d = delimiter ELSE d = ' ' END IF IF ( PRESENT ( mergedelim )) THEN IF ( mergedelim ) THEN res = mergeChars ( str , d ) ELSE res = str END IF ELSE res = str END IF IF ( PRESENT ( rev )) THEN IF ( rev ) THEN res = strReverse ( res ) END IF END IF ! If the delimiter is in the first positions of the string, remove it IF ( INDEX ( res , d ) == 1 ) THEN res = res ( LEN ( d ) + 1 :) END IF DO i = 1 , fieldNumber pos = INDEX ( res , d ) IF ( pos == 0 ) THEN IF ( i /= fieldNumber ) THEN res = '' END IF EXIT ELSE IF ( i == fieldNumber ) THEN res = res (: pos - 1 ) ELSE res = res ( pos + LEN ( d ):) END IF END DO IF ( PRESENT ( rev )) THEN IF ( rev ) THEN res = strReverse ( res ) END IF END IF","tags":"","loc":"sourcefile/include_splitstr.f90.html"},{"title":"include_int2str00000.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_int2str00000.f90 Source Code !Automatic allocation is not allowed in the write statements. ALLOCATE ( character ( len = total_length ) :: str ) WRITE ( str , '(I0.' // num2str ( total_length ) // ')' ) integ","tags":"","loc":"sourcefile/include_int2str00000.f90.html"},{"title":"include_num2strReal.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_num2strReal.f90 Source Code !adding the following statement in the allocate statement wihtout using !variable length is causing memory leaks in valgrind. Using length to !store the information fixes those memory leaks. IF ( startsWith ( formato , '(' )) THEN length = str2num ( splitstr ( formato ( 3 :), 1 , '.' ), 1_i16 ) ELSE length = str2num ( splitstr ( formato ( 2 :), 1 , '.' ), 1_i16 ) END IF ALLOCATE ( character ( len = length ) :: str ) WRITE ( str , '(' // formato // ')' ) num","tags":"","loc":"sourcefile/include_num2strreal.f90.html"},{"title":"include_readMatrix.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_readMatrix.f90 Source Code OPEN ( NEWUNIT = u , FILE = TRIM ( filename ), STATUS = 'OLD' , ACTION = 'READ' ) READ ( u , * ) nrows , ncols , header ALLOCATE ( res ( nrows , ncols )) IF ( header ) THEN READ ( u , * ) END IF DO r = 1 , nrows READ ( u , * ) ( res ( r , c ), c = 1 , ncols ) END DO CLOSE ( u )","tags":"","loc":"sourcefile/include_readmatrix.f90.html"},{"title":"include_writeMatrix.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_writeMatrix.f90 Source Code nrows = SIZE ( matrix , 1 ) ncols = SIZE ( matrix , 2 ) OPEN ( NEWUNIT = u , FILE = TRIM ( filename ), STATUS = 'REPLACE' , ACTION = 'WRITE' ) IF ( PRESENT ( header )) THEN WRITE ( u , * ) nrows , ncols , . TRUE . WRITE ( u , '(A)' ) TRIM ( header ) ELSE WRITE ( u , * ) nrows , ncols , . FALSE . END IF IF ( PRESENT ( formato )) THEN DO r = 1 , nrows WRITE ( u , \"(*(\" // TRIM ( formato ) // \",1X))\" ) ( matrix ( r , c ), c = 1 , ncols ) END DO ELSE DO r = 1 , nrows WRITE ( u , * ) ( matrix ( r , c ), c = 1 , ncols ) END DO END IF CLOSE ( u )","tags":"","loc":"sourcefile/include_writematrix.f90.html"},{"title":"include_ne.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_ne.f90 Source Code IF ( PRESENT ( eps )) THEN eps2 = eps ELSE eps2 = EPSILON ( x1 ) END IF res = ABS ( x1 - x2 ) > eps2","tags":"","loc":"sourcefile/include_ne.f90.html"},{"title":"include_eq.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_eq.f90 Source Code IF ( PRESENT ( eps )) THEN eps2 = eps ELSE eps2 = EPSILON ( x1 ) END IF res = ABS ( x1 - x2 ) < eps2","tags":"","loc":"sourcefile/include_eq.f90.html"},{"title":"include_count_digits_integer.f90 – ecasglez's FortranUtilities","text":"Contents Source Code include_count_digits_integer.f90 Source Code IF ( i < 0 ) THEN num_digits = two ELSE num_digits = one END IF integ = ABS ( i ) integ = integ / ten DO WHILE ( integ /= 0 ) num_digits = num_digits + one integ = integ / ten END DO","tags":"","loc":"sourcefile/include_count_digits_integer.f90.html"},{"title":"mergeChars – ecasglez's FortranUtilities","text":"public pure function mergeChars(str, c) result(res) Merge characters in a string if they are contiguous. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to search inside for contiguous duplicated characters. character(len=*), intent(in) :: c Character to search for contiguous duplications. Return Value character(len=:),\n  ALLOCATABLE String with the selected character contiguous duplications removed. Contents None","tags":"","loc":"proc/mergechars.html"},{"title":"startsWith – ecasglez's FortranUtilities","text":"public elemental function startsWith(str, substr) result(res) Checks if a string starts with a given substring. It can be an array of string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it starts. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str starts with it. Return Value logical True if the string starts with the substring and False otherwise. If\n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. Contents None","tags":"","loc":"proc/startswith.html"},{"title":"endsWith – ecasglez's FortranUtilities","text":"public elemental function endsWith(str, substr) result(res) Checks if a string ends with a given substring. It can be an array of string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it ends. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str ends with it. Return Value logical True if the string ends with the substring and False otherwise. If \n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. Contents None","tags":"","loc":"proc/endswith.html"},{"title":"replace – ecasglez's FortranUtilities","text":"public pure function replace(str, search, repla) result(res) Searches and replaces a substring in a string. It replaces \n all occurences. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to modify character(len=*), intent(in) :: search String to search in str. character(len=*), intent(in) :: repla String to replace in str. Return Value character(len=:),\n  ALLOCATABLE Modified string. Contents None","tags":"","loc":"proc/replace.html"},{"title":"upper – ecasglez's FortranUtilities","text":"public pure function upper(str) result(res) Converts a string to uppercase characters. It works with this dataset:\n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to uppercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to uppercase characters. Contents None","tags":"","loc":"proc/upper.html"},{"title":"lower – ecasglez's FortranUtilities","text":"public pure function lower(str) result(res) Converts a string to lowercase characters. It works with this dataset\n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to lowercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to lowercase characters. Contents None","tags":"","loc":"proc/lower.html"},{"title":"cistrcmp – ecasglez's FortranUtilities","text":"public pure function cistrcmp(str1, str2) result(res) Case-independent string comparison. It works with this dataset: \n 'aáäàâbcdeéëèêfghiíïìîjklmnñoóöòôpqrstuúüùûvwxyz' Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 First string to compare. character(len=*), intent(in) :: str2 Second string to compare Return Value logical True if both strings are equal independently of the case. False otherwise. Contents None","tags":"","loc":"proc/cistrcmp.html"},{"title":"splitstr – ecasglez's FortranUtilities","text":"public interface splitstr Splits a string and returns the portion selected by the user. Contents Module Procedures splitstr_i8 splitstr_i16 splitstr_i32 splitstr_i64 Module Procedures private pure function splitstr_i8(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i8), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i16(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i16), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i32(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i32), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i64(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i64), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string.","tags":"","loc":"interface/splitstr.html"},{"title":"num2str – ecasglez's FortranUtilities","text":"public interface num2str Converts an integer or real variable into a string variable.\n Useful to open files named sequentially. Contents Module Procedures num2str_i8 num2str_i16 num2str_i32 num2str_i64 num2str_sp num2str_dp num2str_qp Module Procedures private pure function num2str_i8(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i16(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i32(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i64(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_sp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_dp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_qp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number","tags":"","loc":"interface/num2str.html"},{"title":"int2str00000 – ecasglez's FortranUtilities","text":"public interface int2str00000 Converts an integer variable into a string variable,\n filling with leading zeros up to the limit imposed by the user.\n Useful to open files named sequentially with leading zeros in the name. Contents Module Procedures int2str00000_i8 int2str00000_i16 int2str00000_i32 int2str00000_i64 Module Procedures private pure function int2str00000_i8(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i8), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i16(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i16), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i32(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i32), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i64(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i64), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number.","tags":"","loc":"interface/int2str00000.html"},{"title":"str2num – ecasglez's FortranUtilities","text":"public interface str2num Converts a string into an integer or real number as specified by the type of variable mold. Contents Module Procedures str2num_i8 str2num_i16 str2num_i32 str2num_i64 str2num_sp str2num_dp str2num_qp Module Procedures private elemental function str2num_i8(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i8), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i8) The number of the input string. private elemental function str2num_i16(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i16), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i16) The number of the input string. private elemental function str2num_i32(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i32), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i32) The number of the input string. private elemental function str2num_i64(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i64), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i64) The number of the input string. private elemental function str2num_sp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=sp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=sp) The number of the input string. private elemental function str2num_dp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=dp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=dp) The number of the input string. private elemental function str2num_qp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=qp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=qp) The number of the input string.","tags":"","loc":"interface/str2num.html"},{"title":"ResetTotalTime – ecasglez's FortranUtilities","text":"public subroutine ResetTotalTime() Sets the starting point to count the total time. Arguments None Contents None","tags":"","loc":"proc/resettotaltime.html"},{"title":"TotalTime – ecasglez's FortranUtilities","text":"public interface TotalTime TotalTime gets the time in seconds (with a precision of microseconds)\n since the beginning of the program or since the last time resetTotalTime is executed. You can use mold input argument to indicate the precision of the output number. Default precision\n is the default precision of your compiler. Contents Module Procedures TotalTime_def TotalTime_sp TotalTime_dp Module Procedures private function TotalTime_def() result(res) Arguments None Return Value real Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses default precision of the compiler used. private function TotalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. private function TotalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold.","tags":"","loc":"interface/totaltime.html"},{"title":"IntervalTime – ecasglez's FortranUtilities","text":"public interface IntervalTime IntervalTime gets the time in seconds (with a precision of microseconds) \n since the last measurement or the time since the begining of the execution if no previous \n measuement is available. This point will be used as a starting point for the next interval. You can use mold input argument to indicate the precision of the output number. Default precision\n is the default precision of your compiler. Contents Module Procedures IntervalTime_def IntervalTime_sp IntervalTime_dp Module Procedures private function IntervalTime_def() result(res) Arguments None Return Value real Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses default precision of the compiler used. private function IntervalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. private function IntervalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold.","tags":"","loc":"interface/intervaltime.html"},{"title":"count_digits_integer – ecasglez's FortranUtilities","text":"public interface count_digits_integer Counts the number of digits of an integer, including the - sign \n in case it is a negative value. Contents Module Procedures count_digits_integer_i8 count_digits_integer_i16 count_digits_integer_i32 count_digits_integer_i64 Module Procedures private pure function count_digits_integer_i8(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i8) The number of digits of the input number. private pure function count_digits_integer_i16(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i16) The number of digits of the input number. private pure function count_digits_integer_i32(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i32) The number of digits of the input number. private pure function count_digits_integer_i64(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i64) The number of digits of the input number.","tags":"","loc":"interface/count_digits_integer.html"},{"title":"is_nan – ecasglez's FortranUtilities","text":"public interface is_nan Determines if the value of the input variable is NaN. Contents Module Procedures is_nan_sp is_nan_dp is_nan_qp Module Procedures private elemental function is_nan_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value.","tags":"","loc":"interface/is_nan.html"},{"title":"is_inf – ecasglez's FortranUtilities","text":"public interface is_inf Determines if the value of the input variable is Infinity. Contents Module Procedures is_inf_sp is_inf_dp is_inf_qp Module Procedures private elemental function is_inf_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value.","tags":"","loc":"interface/is_inf.html"},{"title":"eq – ecasglez's FortranUtilities","text":"public interface eq Tests two real numberes for equality using a tolerance if provided by the user,\n or selecting a tolerance automatically otherwise. Contents Module Procedures eq_sp eq_dp eq_qp Module Procedures private elemental function eq_sp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x1 First real value to compare for equality. real(kind=sp), intent(in) :: x2 Second real value to compare for equality. real(kind=sp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise. private elemental function eq_dp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 First real value to compare for equality. real(kind=dp), intent(in) :: x2 Second real value to compare for equality. real(kind=dp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise. private elemental function eq_qp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x1 First real value to compare for equality. real(kind=qp), intent(in) :: x2 Second real value to compare for equality. real(kind=qp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise.","tags":"","loc":"interface/eq.html"},{"title":"ne – ecasglez's FortranUtilities","text":"public interface ne Tests two real numberes for inequality using a tolerance if provided by the user,\n or selecting a tolerance automatically otherwise. Contents Module Procedures ne_sp ne_dp ne_qp Module Procedures private elemental function ne_sp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x1 First real value to compare for inequality. real(kind=sp), intent(in) :: x2 Second real value to compare for inequality. real(kind=sp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise. private elemental function ne_dp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 First real value to compare for inequality. real(kind=dp), intent(in) :: x2 Second real value to compare for inequality. real(kind=dp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise. private elemental function ne_qp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x1 First real value to compare for inequality. real(kind=qp), intent(in) :: x2 Second real value to compare for inequality. real(kind=qp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise.","tags":"","loc":"interface/ne.html"},{"title":"mean – ecasglez's FortranUtilities","text":"public interface mean Calculates the mean value of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = mean(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the mean value of x . Contents Module Procedures mean_sp mean_dp mean_qp Module Procedures private pure function mean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the average of x. private pure function mean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the average of x. private pure function mean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the average of x.","tags":"","loc":"interface/mean.html"},{"title":"gmean – ecasglez's FortranUtilities","text":"public interface gmean Calculates the geometric mean of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = gmean(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the geometric mean of x . Contents Module Procedures gmean_sp gmean_dp gmean_qp Module Procedures private pure function gmean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the geometric mean of the x. private pure function gmean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the geometric mean of the x. private pure function gmean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the geometric mean of the x.","tags":"","loc":"interface/gmean.html"},{"title":"variance – ecasglez's FortranUtilities","text":"public interface variance Calculates the sample variance of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = variance(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample variance of x . Contents Module Procedures variance_sp variance_dp variance_qp Module Procedures private pure function variance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample variance of x. private pure function variance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample variance of x. private pure function variance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample variance of x.","tags":"","loc":"interface/variance.html"},{"title":"stdev – ecasglez's FortranUtilities","text":"public interface stdev Calculates the sample standard deviation of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = stdev(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample standard deviation of x . Contents Module Procedures stdev_sp stdev_dp stdev_qp Module Procedures private pure function stdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample standard deviation of x. private pure function stdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample standard deviation of x. private pure function stdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample standard deviation of x.","tags":"","loc":"interface/stdev.html"},{"title":"pvariance – ecasglez's FortranUtilities","text":"public interface pvariance Calculates the population variance of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pvariance(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population variance of x . Contents Module Procedures pvariance_sp pvariance_dp pvariance_qp Module Procedures private pure function pvariance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the variance of x. private pure function pvariance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the variance of x. private pure function pvariance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the variance of x.","tags":"","loc":"interface/pvariance.html"},{"title":"pstdev – ecasglez's FortranUtilities","text":"public interface pstdev Calculates the population standard deviation of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pstdev(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population standard deviation of x . Contents Module Procedures pstdev_sp pstdev_dp pstdev_qp Module Procedures private pure function pstdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population standard deviation of x. private pure function pstdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population standard deviation of x. private pure function pstdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population standard deviation of x.","tags":"","loc":"interface/pstdev.html"},{"title":"covariance – ecasglez's FortranUtilities","text":"public interface covariance Calculates the sample covariance between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = covariance(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the sample covariance of x and y . Contents Module Procedures covariance_sp covariance_dp covariance_qp Module Procedures private pure function covariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample covariance between both variables. private pure function covariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample covariance between both variables. private pure function covariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample covariance between both variables.","tags":"","loc":"interface/covariance.html"},{"title":"pcovariance – ecasglez's FortranUtilities","text":"public interface pcovariance Calculates the population covariance between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = pcovariance(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the population covariance of x and y . Contents Module Procedures pcovariance_sp pcovariance_dp pcovariance_qp Module Procedures private pure function pcovariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function pcovariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function pcovariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables.","tags":"","loc":"interface/pcovariance.html"},{"title":"correlation – ecasglez's FortranUtilities","text":"public interface correlation Calculates the correlation coefficient between two variables given in two vectors\n of any size with one dimension applying the following equation: where: and are vectors with real numbers. is how many numbers are included in and . Usage: z = correlation(x,y) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. z = real number of the same kind as x and y with the correlation coefficient of x and y . Contents Module Procedures correlation_sp correlation_dp correlation_qp Module Procedures private pure function correlation_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function correlation_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function correlation_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables.","tags":"","loc":"interface/correlation.html"},{"title":"lin_error_propagation – ecasglez's FortranUtilities","text":"public interface lin_error_propagation Performs linear error (or uncertainties) propagation given the\n sensitivity coefficients and a covariance matrix. The following\n formula is applied: where: is the response whose uncertainty is to be calculated. is a set of input parameters to propagate their uncertainty to . is the vector of sensitivity coefficients of with respect to the\n   different parameters in . is the covariance matrix of the parameters in . Usage: y = lin_error_propagation(s,m) where: s = vector of rank 1 with real numbers containing the sensitivity coefficients. m = array of rank 2 containing the covariance matrix. y = real number of the same kind as s and m with the\n error or uncertainty propagated to this new variable. Contents Module Procedures lin_error_propagation_sp lin_error_propagation_dp lin_error_propagation_qp Module Procedures private pure function lin_error_propagation_sp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=sp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_dp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=dp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_qp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=qp) Real number with the error or uncertainty (variance) propagated to the new variable.","tags":"","loc":"interface/lin_error_propagation.html"},{"title":"median – ecasglez's FortranUtilities","text":"public interface median Calculates the median value.\n This function does not work with quadruple precision numbers\n because of the ordering subroutine written in C++. Usage: y = median(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the median of x . Contents Module Procedures median_sp median_dp Module Procedures private function median_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the median private function median_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the median","tags":"","loc":"interface/median.html"},{"title":"skewness – ecasglez's FortranUtilities","text":"public interface skewness Calculates the sample skewness of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = skewness(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the sample skewness of x . Contents Module Procedures skewness_sp skewness_dp skewness_qp Module Procedures private pure function skewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample skewness of the x. private pure function skewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample skewness of the x. private pure function skewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample skewness of the x.","tags":"","loc":"interface/skewness.html"},{"title":"pskewness – ecasglez's FortranUtilities","text":"public interface pskewness Calculates the population skewness of a set of values given in a vector\n of any size with one dimension applying the following equation: where: is a vector with real numbers. is how many numbers are included in . Usage: y = pskewness(x) where: x = vector of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. y = real number of the same kind as x with the population skewness of x . Contents Module Procedures pskewness_sp pskewness_dp pskewness_qp Module Procedures private pure function pskewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population skewness of the x. private pure function pskewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population skewness of the x. private pure function pskewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population skewness of the x.","tags":"","loc":"interface/pskewness.html"},{"title":"linreg – ecasglez's FortranUtilities","text":"public interface linreg Performs linear regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to measure the goodness of fit. Usage: CALL linreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures linreg_sp linreg_dp linreg_qp Module Procedures private subroutine linreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine linreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine linreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/linreg.html"},{"title":"logreg – ecasglez's FortranUtilities","text":"public interface logreg Performs logarithmic regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL logreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures logreg_sp logreg_dp logreg_qp Module Procedures private subroutine logreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine logreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine logreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/logreg.html"},{"title":"expreg – ecasglez's FortranUtilities","text":"public interface expreg Performs exponential regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL expreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures expreg_sp expreg_dp expreg_qp Module Procedures private subroutine expreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine expreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine expreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/expreg.html"},{"title":"potreg – ecasglez's FortranUtilities","text":"public interface potreg Performs potential regression between two sets of values,\n obtaining parameters and of the following equation. where: and are vectors with real numbers. and are the regression coefficients. Parameter is also calculated to determine the goodness of fit. Usage: CALL potreg(x,y,a,b,R2) where: x and y = vectors of rank 1 with real numbers. See examples to use an array of\n rank larger than 1. a , b = regression coefficients calculated by the subroutine. R2 = the determination coefficient to measure the goodness of fit, calculated by the subroutine. Contents Module Procedures potreg_sp potreg_dp potreg_qp Module Procedures private subroutine potreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine potreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine potreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"interface/potreg.html"},{"title":"mkdir – ecasglez's FortranUtilities","text":"public function mkdir(dir, ignoreErrors) result(res) Creates a directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Path and name of the directory to be created. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message.\n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/mkdir.html"},{"title":"cp – ecasglez's FortranUtilities","text":"public function cp(src, dest, ignoreErrors) result(res) Copies a file or directory. Directories are copied recursively.\n Existing files are overwritten. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be copied. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/cp.html"},{"title":"mv – ecasglez's FortranUtilities","text":"public function mv(src, dest, ignoreErrors) result(res) Moves or renames a file or directory. When moving a directory if the \n destination is an already existing directory which is not empty an error is shown\n and nothing is done. The destination folder must be removed first using function rm. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be moved. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/mv.html"},{"title":"rm – ecasglez's FortranUtilities","text":"public function rm(fname, ignoreErrors) result(res) Removes a file or directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file or directory to be removed. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. Contents None","tags":"","loc":"proc/rm.html"},{"title":"exists – ecasglez's FortranUtilities","text":"public function exists(fname) result(res) Checks if a file or directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be check for existence. Return Value logical True if the file exists. False otherwise. Contents None","tags":"","loc":"proc/exists.html"},{"title":"is_directory – ecasglez's FortranUtilities","text":"public function is_directory(fname, ignoreErrors) result(res) Checks if a directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the directory to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a directory. False otherwise. Contents None","tags":"","loc":"proc/is_directory.html"},{"title":"is_empty – ecasglez's FortranUtilities","text":"public function is_empty(fname, ignoreErrors) result(res) Checks if a file is empty. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is an empty file. False otherwise. Contents None","tags":"","loc":"proc/is_empty.html"},{"title":"is_regular_file – ecasglez's FortranUtilities","text":"public function is_regular_file(fname, ignoreErrors) result(res) Checks if a regular file exists: it is not a directory, symlink, etc. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a regular file. False otherwise. Contents None","tags":"","loc":"proc/is_regular_file.html"},{"title":"is_path_absolute – ecasglez's FortranUtilities","text":"public function is_path_absolute(fname) result(res) Determines if a path is absolute or not. Returns True if path is absolute\n and False if path is relative. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is absolute and false if the path is relative. Contents None","tags":"","loc":"proc/is_path_absolute.html"},{"title":"is_path_relative – ecasglez's FortranUtilities","text":"public function is_path_relative(fname) result(res) Determines if a path is relative or not. Returns True if path is relative\n and False if path is absolute. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is relative and false if the path is absolute. Contents None","tags":"","loc":"proc/is_path_relative.html"},{"title":"extension – ecasglez's FortranUtilities","text":"public function extension(fname) result(res) Determines the extension of a file given its name or path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Extension of the file including the \"dot\". Empty path is returned if no extension is found. Contents None","tags":"","loc":"proc/extension.html"},{"title":"replace_extension – ecasglez's FortranUtilities","text":"public function replace_extension(fname, ext) result(res) Changes the extension of a filename. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. character(len=*), intent(in) :: ext New extension for the fname. Return Value character(len=:),\n  ALLOCATABLE The fname value with the modified extension. Contents None","tags":"","loc":"proc/replace_extension.html"},{"title":"stem – ecasglez's FortranUtilities","text":"public function stem(fname) result(res) Determines the filename without the final extension given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Filename without the final extension. If filename consists of an extension only, the\n extension is returned. Contents None","tags":"","loc":"proc/stem.html"},{"title":"filename – ecasglez's FortranUtilities","text":"public function filename(fname) result(res) Determines the full filename given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Full filename given in the path. Contents None","tags":"","loc":"proc/filename.html"},{"title":"replace_filename – ecasglez's FortranUtilities","text":"public function replace_filename(fname, newname) result(res) Changes the filename of a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. character(len=*), intent(in) :: newname New filename for the fname. Return Value character(len=:),\n  ALLOCATABLE The fname value with the modified filename. Contents None","tags":"","loc":"proc/replace_filename.html"},{"title":"remove_filename – ecasglez's FortranUtilities","text":"public function remove_filename(fname) result(res) Removes the filename from a path. It is similar to function parent_path but this one does not remove railing path separators (if any). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE The fname value with the filename removed. Contents None","tags":"","loc":"proc/remove_filename.html"},{"title":"parent_path – ecasglez's FortranUtilities","text":"public function parent_path(fname) result(res) Determines the path to the parent directory given the path to a file. It is similar\n to function remove_filename but this one removes trailing path separators (if any). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Path of the parent directory without final slash. Contents None","tags":"","loc":"proc/parent_path.html"},{"title":"readMatrix – ecasglez's FortranUtilities","text":"public interface readMatrix Reads a matrix from a file. The file must have the proper format: First line includes the number of rows, the number of columns and a logical\n indicating if the second line is a header line to be skipped. Example: 5 9 T. The second row can be a header or not. Then the matrix comes. The different columns must be separated using blanks. The file is then opened, read and closed. The return variable must have ALLOCATABLE attribute,\n and must not be allocated (the subroutine takes care of allocation but not about deallocation). Contents Module Procedures readMatrix_i8 readMatrix_i16 readMatrix_i32 readMatrix_i64 readMatrix_sp readMatrix_dp readMatrix_qp Module Procedures private subroutine readMatrix_i8(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i8), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i16(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i16), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i32(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i32), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i64(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i64), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_sp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=sp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_dp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=dp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_qp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=qp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information.","tags":"","loc":"interface/readmatrix.html"},{"title":"writeMatrix – ecasglez's FortranUtilities","text":"public interface writeMatrix Writes a matrix to a file. The file will have the following format: First line includes the number of rows, the number of columns and a logical\n indicating if the second line is a header line to be skipped. Example: 5 9 T. The second row can be a header or not. Then the matrix comes. The different columns are separated using blanks. The file is then opened, written and closed. Contents Module Procedures writeMatrix_i8 writeMatrix_i16 writeMatrix_i32 writeMatrix_i64 writeMatrix_sp writeMatrix_dp writeMatrix_qp Module Procedures private subroutine writeMatrix_i8(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i8), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i16(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i16), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i32(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i32), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i64(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i64), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_sp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=sp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3 private subroutine writeMatrix_dp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=dp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3 private subroutine writeMatrix_qp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=qp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3","tags":"","loc":"interface/writematrix.html"},{"title":"FU_Strings – ecasglez's FortranUtilities","text":"Useful tools to manipulate strings in Fortran programs. Uses FU_Prec Contents Interfaces splitstr num2str int2str00000 str2num Functions mergeChars startsWith endsWith replace upper lower cistrcmp Interfaces public interface splitstr Splits a string. Read more… private pure function splitstr_i8(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i8), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i16(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i16), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i32(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i32), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. private pure function splitstr_i64(str, fieldNumber, delimiter, rev, mergedelim) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to split. integer(kind=i64), intent(in) :: fieldNumber Integer indicating which of the divisions to return. character(len=*), intent(in), optional :: delimiter String that the users wants to use as a delimiter for splitting.\n Optional parameter. Default is Space. logical, intent(in), optional :: rev If true start spliting by the end of the string.\n Optional parameter. Default is False. logical, intent(in), optional :: mergedelim If true, contiguous delimiters in the string are merged before splitting.\n Optional parameter. Default is False. Return Value character(len=:),\n  ALLOCATABLE A string with the selected part of str. If the fieldNumber does not exists\n or if the delimiter does not exists it returns an empty string. public interface num2str Converts number into a string. Read more… private pure function num2str_i8(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i16(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i32(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_i64(num) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: num Number to convert to string. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_sp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_dp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number private pure function num2str_qp(num, formato) result(str) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: num Number to convert to string. character(len=*), intent(in) :: formato Format to use in the string variable. Only for real numbers. Return Value character(len=:),\n  ALLOCATABLE String containing the number public interface int2str00000 Converts an integer into a string filling with leading zeros. Read more… private pure function int2str00000_i8(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i8), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i16(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i16), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i32(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i32), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. private pure function int2str00000_i64(integ, total_length) result(str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: integ Integer number to convert. This number MUST be positive. integer(kind=i64), intent(in) :: total_length Number of digits to use, including zeros. This number MUST be positive. Return Value character(len=:),\n  ALLOCATABLE String containing the number. public interface str2num Converts a string into an integer or real. Read more… private elemental function str2num_i8(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i8), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i8) The number of the input string. private elemental function str2num_i16(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i16), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i16) The number of the input string. private elemental function str2num_i32(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i32), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i32) The number of the input string. private elemental function str2num_i64(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. integer(kind=i64), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value integer(kind=i64) The number of the input string. private elemental function str2num_sp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=sp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=sp) The number of the input string. private elemental function str2num_dp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=dp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=dp) The number of the input string. private elemental function str2num_qp(str, mold) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to number. real(kind=qp), intent(in) :: mold Real or integer value to identify the type and kind of the output.\n It is only used to set the type of the return value, so it can be any value. Return Value real(kind=qp) The number of the input string. Functions public pure function mergeChars (str, c) result(res) Author Emilio Castro. Date 14/08/2020. License MIT. Version 1.0. Merge characters in a string if they are contiguous. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to search inside for contiguous duplicated characters. character(len=*), intent(in) :: c Character to search for contiguous duplications. Return Value character(len=:),\n  ALLOCATABLE String with the selected character contiguous duplications removed. public elemental function startsWith (str, substr) result(res) Author Emilio Castro. Date 07/05/2020. License MIT. Version 1.0. Checks if a string starts with a given substring. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it starts. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str starts with it. Return Value logical True if the string starts with the substring and False otherwise. If\n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. public elemental function endsWith (str, substr) result(res) Author Emilio Castro. Date 07/05/2020. License MIT. Version 1.0. Checks if a string ends with a given substring. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String that the user wants to check how it ends. It can be an array. character(len=*), intent(in) :: substr Substring to search to check if str ends with it. Return Value logical True if the string ends with the substring and False otherwise. If \n substr is empty it returns True. If the input is an array, the returned\n values will also be in an array. public pure function replace (str, search, repla) result(res) Author Emilio Castro. Date 10/07/2020. License MIT. Version 1.0. Searches and replaces a substring in a string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to modify character(len=*), intent(in) :: search String to search in str. character(len=*), intent(in) :: repla String to replace in str. Return Value character(len=:),\n  ALLOCATABLE Modified string. public pure function upper (str) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Converts a string to uppercase characters. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to uppercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to uppercase characters. public pure function lower (str) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Converts a string to lowercase characters. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String to convert to lowercase characters. Return Value character(len=:),\n  ALLOCATABLE String converted to lowercase characters. public pure function cistrcmp (str1, str2) result(res) Author Emilio Castro. Date 20/08/2020. License MIT. Version 1.0. Case-independent string comparison. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 First string to compare. character(len=*), intent(in) :: str2 Second string to compare Return Value logical True if both strings are equal independently of the case. False otherwise.","tags":"","loc":"module/fu_strings.html"},{"title":"FU_Timing – ecasglez's FortranUtilities","text":"Tools to measure time spent by functions in Fortran programs.\n The user can use IntervalTime to get the time since the last measure or the time\n since the begining of the execution if no previous measuement is available. This point\n will be used as a starting point for the next interval.\n Use TotalTime to get the time since the beginning of the program or since the last time\n resetTotalTime is executed. Uses FU_Prec Contents Interfaces TotalTime IntervalTime Subroutines ResetTotalTime Interfaces public interface TotalTime Gets the time in seconds since the beginning of the program or since the last time resetTotalTime is executed. Read more… private function TotalTime_def() result(res) Arguments None Return Value real Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses default precision of the compiler used. private function TotalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. private function TotalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Total time spent in seconds since the begining of the program or since the last\n time ResetTotalTime has been used. Uses precision set by mold. public interface IntervalTime Gets the time in seconds since the last measurement. Read more… private function IntervalTime_def() result(res) Arguments None Return Value real Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses default precision of the compiler used. private function IntervalTime_sp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=sp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. private function IntervalTime_dp(mold) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mold Real value to identify the kind of the output.\n It is only used to set the kind of the return value, so it can be any value. Return Value real(kind=dp) Time spent in seconds since the last measurement or since the begining of the program \n if no previous measurement is available. Uses precision set by mold. Subroutines public subroutine ResetTotalTime () Author Emilio Castro. Date 10/09/2020. License MIT. Version 1.0. Sets the starting point to count the total time. Arguments None","tags":"","loc":"module/fu_timing.html"},{"title":"FU_Prec – ecasglez's FortranUtilities","text":"Precision parameters to use in Fortran programs with real or integer variable types. Uses iso_fortran_env Contents Variables sp dp qp i8 i16 i32 i64 Variables Type Visibility Attributes Name Initial integer, public, parameter :: sp = REAL32 Kind parameter to specify a real type with a storage size of 32 bits. integer, public, parameter :: dp = REAL64 Kind parameter to specify a real type with a storage size of 64 bits. integer, public, parameter :: qp = REAL128 Kind parameter to specify a real type with a storage size of 128 bits. integer, public, parameter :: i8 = INT8 Kind parameter to specify an integer type with a storage size of 8 bits. integer, public, parameter :: i16 = INT16 Kind parameter to specify an integer type with a storage size of 16 bits. integer, public, parameter :: i32 = INT32 Kind parameter to specify an integer type with a storage size of 32 bits. integer, public, parameter :: i64 = INT64 Kind parameter to specify an integer type with a storage size of 64 bits.","tags":"","loc":"module/fu_prec.html"},{"title":"FU_Numbers – ecasglez's FortranUtilities","text":"Functions to analyze numbers in Fortran programs. Some of these functions (is_nan and is_inf)\n are now available in the intrinsics module IEEE_ARITHMETIC and\n are provided here only for compatibility with some old programs that use them. Uses FU_Prec ieee_arithmetic Contents Interfaces count_digits_integer is_nan is_inf eq ne Interfaces public interface count_digits_integer Counts the number of digits of an integer. Read more… private pure function count_digits_integer_i8(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i8) The number of digits of the input number. private pure function count_digits_integer_i16(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i16) The number of digits of the input number. private pure function count_digits_integer_i32(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i32) The number of digits of the input number. private pure function count_digits_integer_i64(i) result(num_digits) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: i Integer number whose digits are to be counted. Return Value integer(kind=i64) The number of digits of the input number. public interface is_nan Determines if the value of the input variable is NaN. private elemental function is_nan_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_nan_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is NaN. False otherwise. It will\n have the same rank and dimension as the input value. public interface is_inf Determines if the value of the input variable is Infinity. private elemental function is_inf_sp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_dp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. private elemental function is_inf_qp(val) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: val Value to analize. It can have any rank and dimension Return Value logical True if the variable is Inf. False otherwise. It will\n have the same rank and dimension as the input value. public interface eq Tests two real numbers for equality. Read more… private elemental function eq_sp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x1 First real value to compare for equality. real(kind=sp), intent(in) :: x2 Second real value to compare for equality. real(kind=sp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise. private elemental function eq_dp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 First real value to compare for equality. real(kind=dp), intent(in) :: x2 Second real value to compare for equality. real(kind=dp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise. private elemental function eq_qp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x1 First real value to compare for equality. real(kind=qp), intent(in) :: x2 Second real value to compare for equality. real(kind=qp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if both numbers are equal according to the selected tolerance.\n False otherwise. public interface ne Tests two real numbers for inequality. Read more… private elemental function ne_sp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x1 First real value to compare for inequality. real(kind=sp), intent(in) :: x2 Second real value to compare for inequality. real(kind=sp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise. private elemental function ne_dp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x1 First real value to compare for inequality. real(kind=dp), intent(in) :: x2 Second real value to compare for inequality. real(kind=dp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise. private elemental function ne_qp(x1, x2, eps) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x1 First real value to compare for inequality. real(kind=qp), intent(in) :: x2 Second real value to compare for inequality. real(kind=qp), intent(in), optional :: eps User selected tolerance for the comparison. If not provided\n it will be selected automatically. Return Value logical True if the numbers are not equal according to the selected tolerance.\n False otherwise.","tags":"","loc":"module/fu_numbers.html"},{"title":"FU_Statistics – ecasglez's FortranUtilities","text":"Statistics tools for Fortran programs. Uses FU_Prec Contents Interfaces mean gmean variance stdev pvariance pstdev covariance pcovariance correlation lin_error_propagation median skewness pskewness linreg logreg expreg potreg Interfaces public interface mean Calculates the mean value. Read more… private pure function mean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the average of x. private pure function mean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the average of x. private pure function mean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the mean value. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the average of x. public interface gmean Calculates the geometric mean. Read more… private pure function gmean_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the geometric mean of the x. private pure function gmean_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the geometric mean of the x. private pure function gmean_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the geometric mean. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the geometric mean of the x. public interface variance Calculates the sample variance. Read more… private pure function variance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample variance of x. private pure function variance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample variance of x. private pure function variance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample variance. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample variance of x. public interface stdev Calculates the sample standard deviation. Read more… private pure function stdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample standard deviation of x. private pure function stdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample standard deviation of x. private pure function stdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample standard deviation.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample standard deviation of x. public interface pvariance Calculates the population variance. Read more… private pure function pvariance_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the variance of x. private pure function pvariance_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the variance of x. private pure function pvariance_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population variance.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the variance of x. public interface pstdev Calculates the population standard deviation. Read more… private pure function pstdev_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population standard deviation of x. private pure function pstdev_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population standard deviation of x. private pure function pstdev_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population standard deviation. \n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population standard deviation of x. public interface covariance Calculates the sample covariance between two variables. Read more… private pure function covariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample covariance between both variables. private pure function covariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample covariance between both variables. private pure function covariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample covariance between both variables. public interface pcovariance Calculates the population covariance between two variables. Read more… private pure function pcovariance_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function pcovariance_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function pcovariance_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables. public interface correlation Calculates the correlation coefficient between two variables. Read more… private pure function correlation_sp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population covariance between both variables. private pure function correlation_dp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population covariance between both variables. private pure function correlation_qp(x, y) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population covariance between both variables. public interface lin_error_propagation Performs linear error (or uncertainties) propagation. Read more… private pure function lin_error_propagation_sp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=sp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_dp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=dp) Real number with the error or uncertainty (variance) propagated to the new variable. private pure function lin_error_propagation_qp(sensitivities, matcovar) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: sensitivities Vector of sensitivity coefficients of the new variable with the respect the prior variable.\n It can have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:,:) :: matcovar Covariance matrix with the error or uncertainty of the prior variable.\n Dimensions of sensitivities and matcovar must be in agreement. Return Value real(kind=qp) Real number with the error or uncertainty (variance) propagated to the new variable. public interface median Calculates the median value. Read more… private function median_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=sp) Real number with the median private function median_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the median. It can\n have any size and it must have one dimension. Return Value real(kind=dp) Real number with the median public interface skewness Calculates the sample skewness of a set of values. Read more… private pure function skewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the sample skewness of the x. private pure function skewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the sample skewness of the x. private pure function skewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the sample skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the sample skewness of the x. public interface pskewness Calculates the population skewness of a set of values. Read more… private pure function pskewness_sp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=sp) Real number with the population skewness of the x. private pure function pskewness_dp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=dp) Real number with the population skewness of the x. private pure function pskewness_qp(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers to calculate the population skewness.\n It can have any size and it must have one dimension. Return Value real(kind=qp) Real number with the population skewness of the x. public interface linreg Performs linear regression between two sets of values. Read more… private subroutine linreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine linreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine linreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface logreg Performs logarithmic regression between two sets of values. Read more… private subroutine logreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine logreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine logreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface expreg Performs exponential regression between two sets of values. Read more… private subroutine expreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine expreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine expreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient. public interface potreg Performs potential regression between two sets of values. Read more… private subroutine potreg_sp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=sp), intent(out) :: a Regression coefficient. real(kind=sp), intent(out) :: b Regression coefficient. real(kind=sp), intent(out) :: R2 Determination coefficient. private subroutine potreg_dp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=dp), intent(out) :: a Regression coefficient. real(kind=dp), intent(out) :: b Regression coefficient. real(kind=dp), intent(out) :: R2 Determination coefficient. private subroutine potreg_qp(x, y, a, b, R2) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), DIMENSION(:) :: x Vector of real numbers with the values of the first variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(in), DIMENSION(:) :: y Vector of real numbers with the values of the second variable. It can\n have any size and it must have one dimension. real(kind=qp), intent(out) :: a Regression coefficient. real(kind=qp), intent(out) :: b Regression coefficient. real(kind=qp), intent(out) :: R2 Determination coefficient.","tags":"","loc":"module/fu_statistics.html"},{"title":"FU_Files – ecasglez's FortranUtilities","text":"Useful tools to manipulate files in Fortran programs. Uses FU_Prec iso_c_binding Contents Variables filesep Interfaces readMatrix writeMatrix Functions mkdir cp mv rm exists is_directory is_empty is_regular_file is_path_absolute is_path_relative extension replace_extension stem filename replace_filename remove_filename parent_path Variables Type Visibility Attributes Name Initial character, public, parameter :: filesep = '/' Path separator: '\\' for Windows and '/' for Linux, MacOS and other OS. Interfaces public interface readMatrix Reads a matrix from a file. Read more… private subroutine readMatrix_i8(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i8), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i16(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i16), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i32(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i32), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_i64(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. integer(kind=i64), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_sp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=sp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_dp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=dp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. private subroutine readMatrix_qp(filename, res) Reads a matrix from a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to read the matrix from. real(kind=qp), intent(out), DIMENSION(:,:), ALLOCATABLE :: res Values read from the matrix. This output variable must be allocatable but\n must not be allocated prior to call readMatrix as it is allocated here. However\n deallocation must be done manually by the user when finishes using the information. public interface writeMatrix Writes a matrix to a file. Read more… private subroutine writeMatrix_i8(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i8), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i16(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i16), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i32(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i32), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_i64(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. integer(kind=i64), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: I3 private subroutine writeMatrix_sp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=sp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3 private subroutine writeMatrix_dp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=dp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3 private subroutine writeMatrix_qp(filename, matrix, header, formato) Writes a matrix to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Filename of the file to write the matrix to. real(kind=qp), intent(in), DIMENSION(:,:) :: matrix Values of the matrix to write to the file. character(len=*), intent(in), optional :: header Header to be writen in the second line. character(len=*), intent(in), optional :: formato Format to use for the numbers without parenthesis. Example: F8.3 Functions public function mkdir (dir, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Creates a directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Path and name of the directory to be created. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message.\n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function cp (src, dest, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Copies a file or directory. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be copied. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function mv (src, dest, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Moves or renames a file or directory. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: src Name of the file to be moved. character(len=*), intent(in) :: dest Name of the destination file. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function rm (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Removes a file or directory. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file or directory to be removed. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if the process has been succesful. False in case of error. public function exists (fname) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a file or directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be check for existence. Return Value logical True if the file exists. False otherwise. public function is_directory (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a directory exists. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the directory to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a directory. False otherwise. public function is_empty (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a file is empty. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is an empty file. False otherwise. public function is_regular_file (fname, ignoreErrors) result(res) Author Emilio Castro. Date 16/06/2020. License MIT. Version 1.0. Checks if a regular file exists: it is not a directory, symlink, etc. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Name of the file to be checked. logical, intent(in), optional :: ignoreErrors True to print a detailed description of the error message. \n Optional parameter. Default is False. Return Value logical True if fname is a regular file. False otherwise. public function is_path_absolute (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines if a path is absolute or not Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is absolute and false if the path is relative. public function is_path_relative (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines if a path is relative or not Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Path to a file. Return Value logical True if the path is relative and false if the path is absolute. public function extension (fname) result(res) Author Emilio Castro. Date 27/07/2020. License MIT. Version 1.0. Determines the extension of a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Extension of the file including the \"dot\". Empty path is returned if no extension is found. public function replace_extension (fname, ext) result(res) Author Emilio Castro. Date 21/01/2021. License MIT. Version 1.0. Changes the extension of a filename. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. character(len=*), intent(in) :: ext New extension for the fname. Return Value character(len=:),\n  ALLOCATABLE The fname value with the modified extension. public function stem (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the filename without the final extension given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Filename without the final extension. If filename consists of an extension only, the\n extension is returned. public function filename (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the full filename given a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Full filename given in the path. public function replace_filename (fname, newname) result(res) Author Emilio Castro. Date 21/01/2021. License MIT. Version 1.0. Changes the filename of a path. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. character(len=*), intent(in) :: newname New filename for the fname. Return Value character(len=:),\n  ALLOCATABLE The fname value with the modified filename. public function remove_filename (fname) result(res) Author Emilio Castro. Date 21/01/2021. License MIT. Version 1.0. Removes the filename from a path. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE The fname value with the filename removed. public function parent_path (fname) result(res) Author Emilio Castro. Date 06/08/2020. License MIT. Version 1.0. Determines the path to the parent directory given the path to a file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fname Filename or path to a file. Return Value character(len=:),\n  ALLOCATABLE Path of the parent directory without final slash.","tags":"","loc":"module/fu_files.html"},{"title":"General documentation – ecasglez's FortranUtilities","text":"Only examples are included so far","tags":"","loc":"page//index.html"},{"title":"Compilation – ecasglez's FortranUtilities","text":"Ecasglez's FortranUitilities has been tested in both Windows and Linux platforms using different compilers. Linux Requirements cmake 3.11 or newer. A Fortran compiler compatible with Fortran 2008. Tested with: Gfortran 7.5 or newer. Intel Fortran compiler 16 or newer. Flang compiler from AMD AOCC. PGI compiler 20 or newer from Nvidia HPC-SDK. A C++ compiler compatible with C++ 17. Tested with: G++ 7.5 or newer. Intel C++ compiler 19 or newer. Clang 6 or newer, oficial clang or clang from AMD AOCC. PGI compiler 20 or newer from Nvidia HPC-SDK. Compilation Download the sources and enter directory FortranUtilities. Then create a build directory and enter that directory: mkdir build cd build Prepare compilation files. To use default options and compiler on your system type: cmake .. Optionally you can select an install directory by typing: cmake .. -DCMAKE_INSTALL_PREFIX=/installation/path/ You can specify a different compiler by typing: CC=icc CXX=icc FC=ifort cmake .. You can use a Fortran compiler and a C++ compiler from a different vendor. For example, to use Intel Fortran compiler and G++, type: CC=gcc CXX=g++ FC=ifort cmake .. Compile typing: make Install: make install A static and a shared library are created. Tests programs for both libraries are created too. Windows Requirements cmake 3.11 or newer. MSYS2-Mingw-w64 environment with Gfortran and G++ compilers installed. Compilation Download the sources, open MSYS2-Mingw terminal and enter directory FortranUtilities. Then create a build directory and enter that directory: mkdir build cd build Prepare compilation files. To use default options and compiler on your system type: cmake .. Optionally you can select an install directory by typing: cmake .. -DCMAKE_INSTALL_PREFIX=/installation/path/ Compile typing: make Install: make install","tags":"","loc":"page/Compilation/index.html"},{"title":"Examples – ecasglez's FortranUtilities","text":"Some examples are collected in this pages. The only requirement is to have ecasglez's FortranUtilities compiled.","tags":"","loc":"page/Examples/index.html"},{"title":"Timing and Statistics usage (with OpenMP) – ecasglez's FortranUtilities","text":"Description This example illustrates the use of FU_Prec , FU_Statistics and FU_Timing modules using a simple program.\nIt generates a set of random numbers and then performs a lot of mean, variance and median calculations, and measures the time needed with different number of threads (using OpenMP). Uses up to 7 OpenMP threads. Change this parameter accordingly. Functions used FU_Prec . dp FU_Statistics . mean variance median FU_Timing . ResetTotalTime IntervalTime TotalTime Code PROGRAM FU_example1 ! Example program for FU_Prec, FU_Statistics and FU_Timing modules of ecasglez's FortranUtilities. ! It repeats a lot of mean, variance and median calculations using random numbers. ! Uses OpenMP for parallel execution. ! compile using: gfortran example1.f90 -o example1 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 ! before running: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} ! run using: ./example1 ! license: MIT. !$   USE omp_lib USE FU_Prec , ONLY : dp USE FU_statistics , ONLY : mean , variance , median USE FU_Timing , ONLY : resetTotalTime , IntervalTIme , TotalTime IMPLICIT NONE INTEGER , PARAMETER :: max_num_threads = 7 INTEGER , PARAMETER :: n = 1000 REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: matrix REAL ( KIND = dp ), DIMENSION ( n ) :: media , varianza , mediana INTEGER :: i , k ALLOCATE ( matrix ( 300000 , n )) DO i = 1 , n CALL random_number ( matrix (:, i )) END DO CALL resetTotalTime () DO k = 1 , max_num_threads !$    CALL omp_set_num_threads(k) !$OMP PARALLEL DO DO i = 1 , n media ( i ) = mean ( matrix (:, i )) varianza ( i ) = variance ( matrix (:, i )) mediana ( i ) = median ( matrix (:, i )) END DO !$OMP END PARALLEL DO WRITE ( * , '(A,I0,A,F7.3,A)' ) 'Number of threads: ' , k , '. Elapsed time: ' , IntervalTime (), ' s.' END DO WRITE ( * , '(A,F7.3,A)' ) 'Total elapsed time: ' , TotalTime (), ' s.' DEALLOCATE ( matrix ) END PROGRAM FU_example1 Compilation Compile using the following command. Adjust paths accordingly. gfortran example1.f90 -o example1 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 If no OpenMP libraries are available in your system, you can remove option -fopenmp . The code will work but there will not be any speedup. Execution Before running, since it has been compiled against the shared library: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} Then run with: ./example1 The output of the execution is: Number of threads: 1. Time spent:  22.010 s.\nNumber of threads: 2. Time spent:  11.440 s.\nNumber of threads: 3. Time spent:   8.107 s.\nNumber of threads: 4. Time spent:   6.113 s.\nNumber of threads: 5. Time spent:   5.887 s.\nNumber of threads: 6. Time spent:   4.987 s.\nNumber of threads: 7. Time spent:   4.452 s.\nTotal time spent:  62.995 s.","tags":"","loc":"page/Examples/Example01/index.html"},{"title":"Calculate mean value of a rank 3 array. – ecasglez's FortranUtilities","text":"Description This examples illustrate the use of FU_Prec and FU_Statistics modules using a simple program.\nIt generates an array with rank 3 filled with random numbers showing 3 examples on how to apply function mean (or any other function from FU_Statistics ) to an array of size larger than 1. Functions used FU_Prec . dp FU_Statistics . mean Code PROGRAM FU_example2 ! Example program for FU_Prec and FU_Statistics modules of ecasglez's FortranUtilities, ! showing how to apply FU_Statistics functions to an array with rank larger than 1. ! It shows 3 examples on how to calculate the mean value of a rank 3 array. ! compile using: gfortran example2.f90 -o example2 -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 ! before running: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} ! run using: ./example2 ! license: MIT. USE FU_Prec , ONLY : dp USE FU_statistics , ONLY : mean IMPLICIT NONE INTEGER , PARAMETER :: n = 100 REAL ( KIND = 8 ), DIMENSION (:,:,:), ALLOCATABLE :: matrix REAL ( KIND = 8 ) :: media ALLOCATE ( matrix ( n , n , n )) CALL random_number ( matrix (:,:,:)) !First method. Use RESHAPE. media = mean ( RESHAPE ( matrix ,([ SIZE ( matrix )]))) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' !Second method. Use an array constructor. media = mean ([ matrix ]) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' !Third method. Use sequence association. Use auxiliary function mean3D (see below) media = mean3D ( matrix , SIZE ( matrix )) WRITE ( * , '(A,F9.5,A)' ) 'Mean value: ' , media , '.' DEALLOCATE ( matrix ) CONTAINS FUNCTION mean3D ( a , n ) RESULT ( res ) USE FU_statistics , ONLY : mean IMPLICIT NONE REAL ( KIND = dp ), DIMENSION ( n ), INTENT ( IN ) :: a INTEGER , INTENT ( IN ) :: n REAL ( KIND = dp ) :: res res = mean ( a ) END FUNCTION mean3D END PROGRAM FU_example2 Compilation Compile using the following command. Adjust paths accordingly. gfortran example2.f90 -o example2 -fopenmp -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 Execution Before running, since it has been compiled against the shared library: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} Then run with: ./example2 The output of the execution is: Mean value:   0.50046.\nMean value:   0.50046.\nMean value:   0.50046.","tags":"","loc":"page/Examples/Example02/index.html"},{"title":"Load data and calculate regression coefficients. – ecasglez's FortranUtilities","text":"Description This example illustrates the use of FU_Prec , FU_Files and FU_Statistics modules using a simple program.\nIt reads a dataset from an external file with the proper format and performs different types of regressions to adjust the data. The dataset can be downloaded here . As stated in the documentation of readMatrix the file must have the following format:\nThe first line indicates the number of rows, columns and the presence of a header line in the second line.\nIn this example, the second line of the file is a header, which will be automatically skipped.\nAfter that, the values of the matrix are given.\nThe first lines of this dataset file are: 200 5 T\n#X       LINEAR                 LOG                      EXPONENTIAL             POTENTIAL\n0.1     0.718079165878583   -1.35638917702126         1.458853476235          1.8948792140233\n0.05    1.02619591597279    -2.31765310767541         1.1843683916489         1.34889955912852\n0.15    0.19591897475649    -1.82120101012939         0.595024973297403       1.23781397861872\n0.2     0.313168781703984   -1.45626913073012         0.678804329891996       1.49480956820386\n0.25    0.786822384357196   -0.799471976762694        1.11906961381613        2.0868223843572 Functions used FU_Prec . dp FU_Files . readMatrix FU_Statistics . linreg logreg expreg potreg Code PROGRAM FU_example3 ! Example program for FU_Prec, FU_Files and FU_Statistics modules of ecasglez's FortranUtilities, ! showing how to load data from a file and how to perform different types of regressions. ! The dataset can be downloaded from: https://ecasglez.github.io/FortranUtilities/page/Examples/Example03/example3.dat ! compile using: gfortran example3.f90 -o example3 -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 ! before running: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} ! run using: ./example3 ! license: MIT. USE FU_Prec , ONLY : dp USE FU_Files , ONLY : readMatrix USE FU_statistics , ONLY : linreg , logreg , expreg , potreg IMPLICIT NONE LOGICAL :: exists REAL ( KIND = dp ), DIMENSION (:,:), ALLOCATABLE :: matrix REAL ( KIND = dp ) :: a , b , r2 !First check if the dataset exists. INQUIRE ( FILE = 'example3.dat' , EXIST = exists ) IF (. NOT . exists ) THEN WRITE ( * , * ) 'ERROR: Dataset named \"example03.dat\" not found.' STOP END IF !Load the data in the file. CALL readMatrix ( 'example3.dat' , matrix ) !Calculate regression parameters and print the results. CALL linreg ( matrix (:, 1 ), matrix (:, 2 ), a , b , r2 ) WRITE ( * , '(A,F6.4,A,F6.4,A,F6.4)' ) 'Linear regression:      f(x) = ' , a , ' x + ' , b , '.      Determination coefficient R2 = ' , r2 CALL logreg ( matrix (:, 1 ), matrix (:, 3 ), a , b , r2 ) WRITE ( * , '(A,F6.4,A,F6.4,A,F6.4)' ) 'Logarithmic regression: f(x) = ' , a , ' ln(x) + ' , b , '.  Determination coefficient R2 = ' , r2 CALL expreg ( matrix (:, 1 ), matrix (:, 4 ), a , b , r2 ) WRITE ( * , '(A,F6.4,A,F6.4,A,F6.4)' ) 'Exponential regression: f(x) = ' , b , ' exp(' , a , 'x).    Determination coefficient R2 = ' , r2 CALL potreg ( matrix (:, 1 ), matrix (:, 5 ), a , b , r2 ) WRITE ( * , '(A,F6.4,A,F6.4,A,F6.4)' ) 'Potential regression:   f(x) = ' , b , ' x&#94;' , a , '.        Determination coefficient R2 = ' , r2 DEALLOCATE ( matrix ) END PROGRAM FU_example3 Compilation Compile using the following command. Adjust paths accordingly. gfortran example3.f90 -o example3 -I/path/to/include/ -lFortranUtilities -L/path/to/lib/ -O2 Execution Before running, since it has been compiled against the shared library: export LD_LIBRARY_PATH=/path/to/lib:${LD_LIBRARY_PATH} Then run with: ./example3 The output of the execution is: Linear regression:      f(x) = 0.7948 x + 0.5358.      Determination coefficient R2 = 0.9846\nLogarithmic regression: f(x) = 0.9877 ln(x) + 0.5260.  Determination coefficient R2 = 0.9150\nExponential regression: f(x) = 0.8921 exp(0.1926x).    Determination coefficient R2 = 0.9214\nPotential regression:   f(x) = 3.6021 x&#94;0.4330.        Determination coefficient R2 = 0.9764 This results and the dataset can be plotted using a external tool to see the adjustment:","tags":"","loc":"page/Examples/Example03/index.html"}]}